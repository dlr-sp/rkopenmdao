"""Checkpointing implementation that saves all intermediate data."""

from collections import deque
from copy import deepcopy
from dataclasses import dataclass

from rkopenmdao.checkpoint_interface.checkpoint_interface import CheckpointInterface
from rkopenmdao.time_integration_state import TimeIntegrationState


@dataclass
class AllCheckpointer(CheckpointInterface):
    """
    Checkpointer that sets checkpoints for all time steps. Memory inefficient, but
    fast and works with adaptive time stepping.

    Parameters
    ----------
    integration_control: IntegrationControl
        IntegrationControl object for sharing data between ODE time discretization and
        time integration.
    run_step_func: Callable[[TimeIntegrationState], TimeIntegrationState]
        Function for the computation of one step of the forward (primal) time
        integration. Input is the state of the time integration at the start of the
        step, return value the state at the end of the same step.
    run_step_jacvec_rev_func: Callable[
        [TimeIntegrationState, TimeIntegrationState], TimeIntegrationState
    ]
        Function for the computation of one step of the reverse (linear) time
        integration. Inputs are the state of the time integration during the step
        acting as linearization point, as well as the perturbations for the end of the
        time step. Return value is the perturbation for the start of the time step.
    state: TimeIntegrationState
        Time integration state on which all computations for the forward (primal) time
        integration are performed.
    state_perturbation: TimeIntegrationState
        Time integration state on which all computations for the reverse (linear) time
        integration are performed.
    """

    def __post_init__(self):
        """Reserves memory for time integration state and perturbation."""
        self._storage = deque()  # queue of TimeIntegrationStates

    def create_checkpointer(self):
        """Resets internal storage such that checkpointing can begin anew."""
        self._storage.clear()

    def iterate_forward(
        self, initial_state: TimeIntegrationState
    ) -> TimeIntegrationState:
        """
        Forward iteration of the time integration, saving all intermediate time
        integration states as checkpoints.

        Parameters
        ----------
        initial_state: TimeIntegrationState
            The state at the beginning of the time integration process.

        Returns
        -------
        final_state: TimeIntegrationState
            The resulting state after completing all time steps.
        """
        self.state.set(initial_state)
        while self.integration_control.termination_condition_status():
            self.state.set(self.run_step_func(self.state))
            self._storage.append(deepcopy(self.state))
        return self.state

    def iterate_reverse(
        self, final_state_perturbation: TimeIntegrationState
    ) -> TimeIntegrationState:
        """
        Reverse iteration of time integration, using checkpoints generated by
        `iterated_forward`.

        Parameters
        ----------
        final_state_perturbation: TimeIntegrationState
            The perturbation of the final state used as starting point for reverse
            iteration.

        Returns
        -------
        initial_state_perturbation: TimeIntegrationState
            The resulting perturbation of the initial state after completing all time
            steps.
        """
        self.state_perturbation.set(final_state_perturbation)
        while self.integration_control.step > 0:
            state = self._storage.pop()
            self.state_perturbation.set(
                self.run_step_jacvec_rev_func(state, self.state_perturbation)
            )
            self.integration_control.decrement_step()
        return self.state_perturbation
