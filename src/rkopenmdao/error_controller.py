"""Contains the class for the error controller of the adaptive Runge-Kutta schemes"""

from dataclasses import dataclass
import warnings

import numpy as np

from rkopenmdao.errors import OuterErrorControllerError, InnerErrorControllerError


@dataclass
class ErrorControllerStatus:
    """Contains the values generated by a call of the error controller, namely the
    newly suggested step size and the acceptance of the step."""

    step_size_suggestion: float
    acceptance: bool


@dataclass
class ErrorControllerConfig:
    """
    Contains general configuration options for the ErrorController class.
    """

    tol: float = 1e-6
    lower_bound: float = 0
    upper_bound: float = np.inf
    safety_factor: float = 0.95
    max_iter: int = 5


class ErrorController:
    r"""
    Error controller that estimates the next time-difference jumps of a Runge-Kutta
    scheme in accordance to a specified tolerance and uses the following equation:

    (\Delta t)^{[n+1]} = \kappa (\Delta t)^{[n]}
    \left \{\frac{\varepsilon}{\left\Vert \delta^{[n+1]} \right\Vert} \right\}^\alpha
    \left \{\frac{\left\Vert  \delta ^{[n]} \right\Vert}{\varepsilon}\right\} ^\beta
    \left\{\frac{\varepsilon}{\left\Vert \delta^{[n-1]} \right\Vert}\right\}^\gamma
    \left\{\frac{(\Delta t)^{[n]}}{(\Delta t)^{[n-1]}}\right\}^a
    \left\{\frac{(\Delta t)^{[n-1]}}{(\Delta t)^{[n-2]}}\right\}^b

    Attributes
    ----------
    alpha : float
        The exponent constant to the tolerance by the current norm.
    beta : float, optional
        The exponent constant to the current norm by the last norm.
    gamma : float, optional
        The exponent constant to the last norm by the prior norm.
    a : float, optional
        The exponent constant to the current time-difference by the last.
        time-difference
    b : float, optional
        The exponent constant to the last time-difference by the prior one.
    tol : float, optional
        The tolerance of the error controller.
    safety_factor: float, optional
        Safety factor in the equation smaller than 1.
    max_iter: int, optional
        Threshold for number of times the controller is attempted.
        over the course of one step.
    lower_bound: float, optional
        Minimum step size allowed.
    upper_bound: float, optional
        Maximum step size allowed.
    name: str, optional
        Name of the error controller.



    Methods
    -------
    __call__(solution, embedded_solution, delta_t)
        A call function which returns a delta_t suggestion and
        an acceptance status.
    __str__()
        Prints the class data.
    """

    def __init__(
        self,
        alpha,
        beta: float = 0,
        gamma: float = 0,
        a: float = 0,
        b: float = 0,
        config: ErrorControllerConfig = ErrorControllerConfig(),
        name: str = "ErrorController",
    ):
        # Constant parameters for the error controller equation
        # -----------
        # 1. General parameters
        self.config = config
        # 2. Exponents for norm sensitivities
        self.alpha = alpha
        self.beta = beta
        self.gamma = gamma
        # 3. Exponents for delta_t Sensitivities
        self.a = a
        self.b = b
        # -----------
        self.inner_most = True  # Indicator if it is not associated with a decorator
        self.name = "Outermost " + name
        self.width = 0

    def __call__(
        self,
        error_measure: float,
        delta_t: float,
        remaining_time: float,
        error_history: np.ndarray,
        step_size_history: np.ndarray,
    ) -> ErrorControllerStatus:
        """
        A call function which returns a delta_t suggestion and
        an acceptance status.
        """
        status = self._run(
            error_measure, delta_t, remaining_time, error_history, step_size_history
        )
        if not status.acceptance:
            if status.step_size_suggestion > delta_t and self.inner_most:
                raise OuterErrorControllerError(
                    f"""Suggested delta T {status.step_size_suggestion} is larger than 
                    delta t {delta_t} on failure."""
                )
        return status

    def _run(
        self,
        error_measure: float,
        delta_t: float,
        remaining_time: float,
        error_history: np.ndarray,
        step_size_history: np.ndarray,
    ) -> ErrorControllerStatus:
        """
        Estimates next possible step size for a given state and embedded solution
        and returns whether the next step size meets the tolerance.

        Parameters
        ----------
        solution : np.ndarray
            The solution of the current time step.
        embedded_solution : np.ndarray
            The embedded solution of the current time step.
        delta_t:
            current time step size.

        Returns
        -------
        Tuple(float,bool)
            1. A suggestion to next time step size.
            2. Acceptance Status.
        """
        success = False
        if (
            np.abs(delta_t - self.config.lower_bound) < 1e-10
            or np.abs(delta_t - remaining_time) < 1e-10
            or error_measure <= self.config.tol
        ):
            success = True

        if error_measure != 0:
            new_delta_t = self._estimate_next_step_function(
                error_measure, delta_t, error_history, step_size_history
            )
        else:
            new_delta_t = delta_t
            warnings.warn(
                """Current error norm is 0, can't estimate new step size
                and using old one."""
            )

        new_delta_t = max(
            self.config.lower_bound, min(self.config.upper_bound, new_delta_t)
        )
        if remaining_time - (delta_t + new_delta_t) < self.config.lower_bound:
            new_delta_t = remaining_time
        return ErrorControllerStatus(new_delta_t, success)

    def _estimate_next_step_function(
        self,
        error_measure: float,
        delta_t: float,
        error_history: np.ndarray,
        step_size_history: np.ndarray,
    ) -> float:
        """
        Estimates the delta time of the current or next time step.
        """
        delta_t_new = self.config.safety_factor * delta_t
        delta_t_new *= (self.config.tol / error_measure) ** self.alpha
        delta_t_new *= (error_history[0] / self.config.tol) ** self.beta
        delta_t_new *= (self.config.tol / error_history[1]) ** self.gamma
        if step_size_history[0] != 0.0:
            delta_t_new *= (delta_t / step_size_history[0]) ** self.a
            if step_size_history[1] != 0.0:
                delta_t_new *= (step_size_history[0] / step_size_history[1]) ** self.b
        return delta_t_new

    def __str__(self):
        """
        Prints the class data as following:
            ---------------------------
            |     ErrorController     |
            ---------------------------
            | alpha: 1.0              |
            | beta: 2.0               |
            | gamma: 3.0              |
            | a: 4.0                  |
            | b: 5.0                  |
            | tol: 0.001              |
            | safety_factor: 0.95     |
            ---------------------------
        """
        _vars = vars(self).copy()
        name = _vars.pop("name")
        _str_list = []
        for i, var in enumerate(_vars):
            if _vars[var] is not None and _vars[var] != 0:
                if var == "error_controller":
                    continue
                _str_list.append(f"{var}: {_vars[var]}")
        width = len(max(_str_list, key=len)) + 4
        self.width = width
        title = name.center(width - 2)
        _str = "-" * width + "\n" + f"|{title}" + "|\n" + "-" * width + "\n"
        for i in _str_list:
            _str += "| " + i + " " * (width - 3 - len(i)) + "|\n"
        _str += "-" * width
        return _str


@dataclass
class ErrorControllerDecorator(ErrorController):
    """Error Controller Decorator that wraps the base error controller with
    a different error controller in case of failure."""

    def __init__(
        self,
        alpha,
        error_controller: ErrorController,
        beta: float = 0,
        gamma: float = 0,
        a: float = 0,
        b: float = 0,
        name: str = "ErrorController",
    ):
        self.error_controller = error_controller
        self.error_controller.inner_most = False
        self.error_controller.name = self.error_controller.name.replace(
            "Inner ", " ", 1
        )
        super().__init__(
            alpha=alpha,
            beta=beta,
            gamma=gamma,
            a=a,
            b=b,
        )
        self.config = error_controller.config
        self.is_not_inner = True
        self.name = "Innermost " + name
        self.outer_counter = 0

    def __call__(
        self,
        error_measure: float,
        delta_t: float,
        remaining_time: float,
        error_history: np.ndarray,
        step_size_history: np.ndarray,
    ) -> ErrorControllerStatus:
        """
        A call function which returns a delta_t suggestion and
        an acceptance status.
        """
        if self.is_not_inner:
            try:
                status = self.error_controller(
                    error_measure,
                    delta_t,
                    remaining_time,
                    error_history,
                    step_size_history,
                )
                if not status.acceptance:
                    self.outer_counter += 1
                    if not (
                        status.step_size_suggestion < delta_t
                        and self.outer_counter <= self.config.max_iter
                    ):
                        raise OuterErrorControllerError(
                            f"""Suggested delta T {status.step_size_suggestion} is 
                            larger than delta t {delta_t} on failure."""
                        )
                self.outer_counter = 0
                return status
            except OuterErrorControllerError:
                return self._run(
                    error_measure,
                    delta_t,
                    remaining_time,
                    error_history,
                    step_size_history,
                )
        else:
            return self._run(
                error_measure,
                delta_t,
                remaining_time,
                error_history,
                step_size_history,
            )

    def __str__(self):
        """Prints the class data."""
        current_str = super().__str__()
        return f"""{self.error_controller.__str__()}
        \n{' '*int(self.width/2)}+
        \n{current_str}"""

    def _run(
        self,
        error_measure: float,
        delta_t: float,
        remaining_time: float,
        error_history: np.ndarray,
        step_size_history: np.ndarray,
    ) -> ErrorControllerStatus:
        """
        Estimates next possible step size for a given state and embedded solution
        and returns whether the next step size meets the tolerance.

        Parameters
        ----------
        solution : np.ndarray
            The solution of the current time step.
        embedded_solution : np.ndarray
            The embedded solution of the current time step.
        delta_t:
            current time step size.

        Returns
        -------
        Tuple(float,bool)
            1. A suggestion to next time step size.
            2. Acceptance Status.
        """

        self.is_not_inner = True
        status = super()._run(
            error_measure, delta_t, remaining_time, error_history, step_size_history
        )
        if not status.acceptance:
            self.is_not_inner = False
            if status.step_size_suggestion > delta_t and self.inner_most:
                raise InnerErrorControllerError(
                    f"""Suggested delta T {status.step_size_suggestion} is larger than 
                    delta t {delta_t} on failure."""
                )
        return status
