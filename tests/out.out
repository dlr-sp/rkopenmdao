============================= test session starts ==============================
platform linux -- Python 3.9.16, pytest-7.1.3, pluggy-1.0.0
rootdir: /scratch/ws/m0/shuv_im-shuv_im/shuv_im-imris_workspace-1724036464/MDAO/rkopenmdao/rkopenmdao
collected 120 items

test_component_test_adaptive.py ........................................ [ 33%]
..................................................FFFF..FFFF..........FF [ 93%]
FF..FFFF                                                                 [100%]

=================================== FAILURES ===================================
_ test_time_integration_with_parameter_partials[PID-SimpleErrorEstimator-AllCheckpointer-butcher_tableau0-1.0-TestComp1-0.0] _

test_class = <class 'tests.test_components.TestComp1'>, initial_time = 0.0
parameter = 1.0
butcher_tableau = <rkopenmdao.butcher_tableau.EmbeddedButcherTableau object at 0x15551f7d7ee0>
checkpointing_implementation = <class 'rkopenmdao.checkpoint_interface.all_checkpointer.AllCheckpointer'>
test_estimator = <class 'rkopenmdao.error_estimator.SimpleErrorEstimator'>
test_controller = <function PID at 0x1555201d5550>

    @pytest.mark.rk
    @pytest.mark.rk_openmdao
    @pytest.mark.parametrize(
        "test_class, initial_time",
        (
            [TestComp1, 0.0],
            [TestComp1, 1.0],
        ),
    )
    @pytest.mark.parametrize("parameter", [1.0])
    @pytest.mark.parametrize(
        "butcher_tableau",
        [
            heun_euler,
            two_stage_dirk,
            three_stage_esdirk,
            four_stage_esdirk,
            five_stage_esdirk
        ]
    )
    @pytest.mark.parametrize(
        "checkpointing_implementation",
        [
            NoCheckpointer,
            AllCheckpointer,
        ],
    )
    @pytest.mark.parametrize(
        "test_estimator",
        [
            SimpleErrorEstimator,
            ImprovedErrorEstimator
        ]
    )
    @pytest.mark.parametrize(
        "test_controller",
        [
            Integral,
            H0_110,
            PID
        ]
    )
    def test_time_integration_with_parameter_partials(
        test_class, initial_time, parameter, butcher_tableau, checkpointing_implementation, test_estimator, test_controller
    ):
        """Tests the partials of the time integration of the different components."""
        termination_criterion = TerminationCriterion('end_time', initial_time + 0.01)
        integration_control = IntegrationControl(initial_time, termination_criterion, 0.001)
        time_integration_prob = om.Problem()
        time_integration_prob.model.add_subsystem(
            "test_comp", test_class(integration_control=integration_control)
        )
    
        time_integration_prob.model.nonlinear_solver = om.NewtonSolver(
            solve_subsystems=True
        )
        time_integration_prob.model.linear_solver = om.ScipyKrylov()
    
        runge_kutta_prob = om.Problem()
        runge_kutta_prob.model.add_subsystem(
            "rk_integrator",
            RungeKuttaIntegrator(
                time_stage_problem=time_integration_prob,
                butcher_tableau=butcher_tableau,
                integration_control=integration_control,
                time_integration_quantities=["x"],
                time_independent_input_quantities=["b"],
                checkpointing_type=checkpointing_implementation,
                error_controller=test_controller,
                error_estimator_type=test_estimator,
                adaptive_time_stepping=True,
            ),
            promotes=["*"],
        )
    
        runge_kutta_prob.setup()
        runge_kutta_prob["b"] = parameter
        runge_kutta_prob.run_model()
        if checkpointing_implementation == NoCheckpointer:
            with pytest.raises(NotImplementedError):
                runge_kutta_prob.check_partials(excludes=["Jfd","fd","Jfor-Jfd","Jrev-Jfd"])
        else:
            data = runge_kutta_prob.check_partials()
>           assert_check_partials(data)

test_component_test_adaptive.py:517: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = {'rk_integrator': {('x_final', 'b'): {'J_fd': array([[0.01010045]]), 'J_fwd': array([[0.01010044]]), 'J_rev': array([[...ErrorTuple(forward=6.789408812934994e-09, reverse=6.789409034979599e-09, forward_reverse=2.220446049250313e-16), ...}}}
atol = 1e-06, rtol = 1e-06

    def assert_check_partials(data, atol=1e-6, rtol=1e-6):
        """
        Raise assertion if any entry from the return from check_partials is above a tolerance.
    
        Parameters
        ----------
        data : dict of dicts of dicts
                First key:
                    is the component name;
                Second key:
                    is the (output, input) tuple of strings;
                Third key:
                    is one of ['rel error', 'abs error', 'magnitude', 'J_fd', 'J_fwd', 'J_rev'];
    
                For 'rel error', 'abs error', 'magnitude' the value is: A tuple containing norms for
                    forward - fd, adjoint - fd, forward - adjoint.
                For 'J_fd', 'J_fwd', 'J_rev' the value is: A numpy array representing the computed
                    Jacobian for the three different methods of computation.
        atol : float
            absolute error. Default is 1e-6.
        rtol : float
            relative error. Default is 1e-6.
        """
        error_string = ''
        absrel_header = 'abs/rel'
        wrt_header = '< output > wrt < variable >'
        norm_value_header = 'norm value'
        len_absrel_width = len(absrel_header)
        norm_types = ['fwd-fd', 'rev-fd', 'fd-rev']
        len_norm_type_width = max(len(s) for s in norm_types)
    
        for comp in data:
            len_wrt_width = len(wrt_header)
            len_norm_width = len(norm_value_header)
            bad_derivs = []
    
            # Find all derivatives whose errors exceed tolerance.
            # Also, size the output to precompute column extents.
            for (var, wrt) in data[comp]:
                pair_data = data[comp][var, wrt]
                for error_type, tolerance in [('abs error', atol), ('rel error', rtol), ]:
                    actual = pair_data[error_type]
                    for error_val, mode in zip(actual, norm_types):
                        in_error = False
    
                        if error_val is None:
                            # Reverse derivatives only computed on matrix free comps.
                            continue
    
                        if not np.isnan(error_val):
                            if not np.allclose(error_val, 0.0, atol=tolerance):
    
                                if error_type == 'rel error' and mode == 'fwd-fd' and \
                                   np.allclose(pair_data['J_fwd'], 0.0, atol=atol) and \
                                   np.allclose(pair_data['J_fd'], 0.0, atol=atol):
                                    # Special case: both fd and fwd are really tiny, so we want to
                                    # ignore the rather large relative errors.
                                    in_error = False
                                else:
                                    # This is a bona-fide error.
                                    in_error = True
    
                        elif error_type == 'abs error' and mode == 'fwd-fd':
                            # Either analytic or approximated derivatives contain a NaN.
                            in_error = True
    
                        if in_error:
                            wrt_string = '{0} wrt {1}'.format(var, wrt)
                            norm_string = '{}'.format(error_val)
                            bad_derivs.append((wrt_string, norm_string, error_type, mode))
                            len_wrt_width = max(len_wrt_width, len(wrt_string))
                            len_norm_width = max(len_norm_width, len(norm_string))
    
            if bad_derivs:
                comp_error_string = ''
                for wrt_string, norm_string, error_type, mode in bad_derivs:
                    err_msg = '{0} | {1} | {2} | {3}'.format(
                        pad_name(wrt_string, len_wrt_width),
                        pad_name(error_type.split()[0], len_absrel_width),
                        pad_name(mode, len_norm_type_width),
                        pad_name(norm_string, len_norm_width)) + '\n'
                    comp_error_string += err_msg
    
                name_header = 'Component: {}\n'.format(comp)
                len_name_header = len(name_header)
                header = len_name_header * '-' + '\n'
                header += name_header
                header += len_name_header * '-' + '\n'
                header += '{0} | {1} | {2} | {3}'.format(
                    pad_name(wrt_header, len_wrt_width),
                    pad_name(absrel_header, len_absrel_width),
                    pad_name('norm', len_norm_type_width),
                    pad_name(norm_value_header, len_norm_width),
                ) + '\n'
                header += '{0} | {1} | {2} | {3}'.format(
                    len_wrt_width * '-',
                    len_absrel_width * '-',
                    len_norm_type_width * '-',
                    len_norm_width * '-',
                ) + '\n'
                comp_error_string = header + comp_error_string
                error_string += comp_error_string
    
        # if error string then raise error with that string
        if error_string:
            header_line1 = 'Assert Check Partials failed for the following Components'
            header_line2 = 'with absolute tolerance = {} and relative tolerance = {}'.format(atol, rtol)
            header_width = max(len(header_line1), len(header_line2))
            header = '\n' + header_width * '=' + '\n'
            header += header_line1 + '\n'
            header += header_line2 + '\n'
            header += header_width * '=' + '\n'
            error_string = header + error_string
>           raise ValueError(error_string)
E           ValueError: 
E           ==============================================================
E           Assert Check Partials failed for the following Components
E           with absolute tolerance = 1e-06 and relative tolerance = 1e-06
E           ==============================================================
E           -------------------------
E           Component: rk_integrator
E           -------------------------
E           < output > wrt < variable > | abs/rel | norm   | norm value            
E           --------------------------- | ------- | ------ | ----------------------
E           x_final wrt b               | rel     | fwd-fd | 1.3225009773924895e-06
E           x_final wrt b               | rel     | rev-fd | 1.3225009779077312e-06

/home/shuv_im/.spack/rev.23.05/install/linux-rocky8-zen2/gcc-10.4.0/py-openmdao-3.9.1-dlr.6-w57zdo/lib/python3.9/site-packages/openmdao/utils/assert_utils.py:225: ValueError
----------------------------- Captured stdout call -----------------------------


Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting fwd-mode jacvec product


Resetting error estimator.


Starting step 1 of fwd-mode jacvec product.
Time = 0.0, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 1.
Starting stage 2 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 1.

Finished step 1 of fwd-mode jacvec product.


Starting step 2 of fwd-mode jacvec product.
Time = 0.001, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 2.
Starting stage 2 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 2.

Finished step 2 of fwd-mode jacvec product.


Starting step 3 of fwd-mode jacvec product.
Time = 0.002449152734285814, dTime = 0.0014491527342858142.

Starting stage 1 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 3.
Starting stage 2 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 3.

Finished step 3 of fwd-mode jacvec product.


Starting step 4 of fwd-mode jacvec product.
Time = 0.007138190504098224, dTime = 0.00468903776981241.

Starting stage 1 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 4.
Starting stage 2 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 4.

Finished step 4 of fwd-mode jacvec product.



Finished fwd-mode jacvec product




Starting fwd-mode jacvec product


Resetting error estimator.


Starting step 1 of fwd-mode jacvec product.
Time = 0.0, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 1.
Starting stage 2 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 1.

Finished step 1 of fwd-mode jacvec product.


Starting step 2 of fwd-mode jacvec product.
Time = 0.001, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 2.
Starting stage 2 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 2.

Finished step 2 of fwd-mode jacvec product.


Starting step 3 of fwd-mode jacvec product.
Time = 0.002449152734285814, dTime = 0.0014491527342858142.

Starting stage 1 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 3.
Starting stage 2 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 3.

Finished step 3 of fwd-mode jacvec product.


Starting step 4 of fwd-mode jacvec product.
Time = 0.007138190504098224, dTime = 0.00468903776981241.

Starting stage 1 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 4.
Starting stage 2 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 4.

Finished step 4 of fwd-mode jacvec product.



Finished fwd-mode jacvec product




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting rev-mode jacvec product



Starting step 4 of rev-mode jacvec product.
Time = 0.007138190504098224, dTime = 0.002861809495901776.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 4.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 4.

Finishing step 4 of rev-mode jacvec product.


Starting step 3 of rev-mode jacvec product.
Time = 0.002449152734285814, dTime = 0.00468903776981241.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 3.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 3.

Finishing step 3 of rev-mode jacvec product.


Starting step 2 of rev-mode jacvec product.
Time = 0.001, dTime = 0.0014491527342858142.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 2.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 2.

Finishing step 2 of rev-mode jacvec product.


Starting step 1 of rev-mode jacvec product.
Time = 0.0, dTime = 0.001.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 1.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 1.

Finishing step 1 of rev-mode jacvec product.



Finished rev-mode jacvec product




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute


-----------------------------------------------
Component: RungeKuttaIntegrator 'rk_integrator'
-----------------------------------------------
  rk_integrator: 'x_final' wrt 'b'
     Forward Magnitude: 1.010044e-02
     Reverse Magnitude: 1.010044e-02
          Fd Magnitude: 1.010045e-02 (fd:forward)
    Absolute Error (Jfor - Jfd) : 1.335785e-08
    Absolute Error (Jrev - Jfd) : 1.335785e-08
    Absolute Error (Jfor - Jrev): 5.204170e-18

    Relative Error (Jfor - Jfd) / Jfd : 1.322501e-06 *
    Relative Error (Jrev - Jfd) / Jfd : 1.322501e-06 *
    Relative Error (Jfor - Jrev) / Jfd: 5.152415e-16

    Raw Forward Derivative (Jfor)
[[0.01010044]]

    Raw Reverse Derivative (Jrev)
[[0.01010044]]

    Raw FD Derivative (Jfd)
[[0.01010045]]

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  rk_integrator: 'x_final' wrt 'x_initial'
     Forward Magnitude: 1.010050e+00
     Reverse Magnitude: 1.010050e+00
          Fd Magnitude: 1.010050e+00 (fd:forward)
    Absolute Error (Jfor - Jfd) : 6.789409e-09
    Absolute Error (Jrev - Jfd) : 6.789409e-09
    Absolute Error (Jfor - Jrev): 2.220446e-16

    Relative Error (Jfor - Jfd) / Jfd : 6.721853e-09
    Relative Error (Jrev - Jfd) / Jfd : 6.721853e-09
    Relative Error (Jfor - Jrev) / Jfd: 2.198352e-16

    Raw Forward Derivative (Jfor)
[[1.01005015]]

    Raw Reverse Derivative (Jrev)
[[1.01005015]]

    Raw FD Derivative (Jfd)
[[1.01005015]]

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
_ test_time_integration_with_parameter_partials[PID-SimpleErrorEstimator-AllCheckpointer-butcher_tableau0-1.0-TestComp1-1.0] _

test_class = <class 'tests.test_components.TestComp1'>, initial_time = 1.0
parameter = 1.0
butcher_tableau = <rkopenmdao.butcher_tableau.EmbeddedButcherTableau object at 0x15551f7d7ee0>
checkpointing_implementation = <class 'rkopenmdao.checkpoint_interface.all_checkpointer.AllCheckpointer'>
test_estimator = <class 'rkopenmdao.error_estimator.SimpleErrorEstimator'>
test_controller = <function PID at 0x1555201d5550>

    @pytest.mark.rk
    @pytest.mark.rk_openmdao
    @pytest.mark.parametrize(
        "test_class, initial_time",
        (
            [TestComp1, 0.0],
            [TestComp1, 1.0],
        ),
    )
    @pytest.mark.parametrize("parameter", [1.0])
    @pytest.mark.parametrize(
        "butcher_tableau",
        [
            heun_euler,
            two_stage_dirk,
            three_stage_esdirk,
            four_stage_esdirk,
            five_stage_esdirk
        ]
    )
    @pytest.mark.parametrize(
        "checkpointing_implementation",
        [
            NoCheckpointer,
            AllCheckpointer,
        ],
    )
    @pytest.mark.parametrize(
        "test_estimator",
        [
            SimpleErrorEstimator,
            ImprovedErrorEstimator
        ]
    )
    @pytest.mark.parametrize(
        "test_controller",
        [
            Integral,
            H0_110,
            PID
        ]
    )
    def test_time_integration_with_parameter_partials(
        test_class, initial_time, parameter, butcher_tableau, checkpointing_implementation, test_estimator, test_controller
    ):
        """Tests the partials of the time integration of the different components."""
        termination_criterion = TerminationCriterion('end_time', initial_time + 0.01)
        integration_control = IntegrationControl(initial_time, termination_criterion, 0.001)
        time_integration_prob = om.Problem()
        time_integration_prob.model.add_subsystem(
            "test_comp", test_class(integration_control=integration_control)
        )
    
        time_integration_prob.model.nonlinear_solver = om.NewtonSolver(
            solve_subsystems=True
        )
        time_integration_prob.model.linear_solver = om.ScipyKrylov()
    
        runge_kutta_prob = om.Problem()
        runge_kutta_prob.model.add_subsystem(
            "rk_integrator",
            RungeKuttaIntegrator(
                time_stage_problem=time_integration_prob,
                butcher_tableau=butcher_tableau,
                integration_control=integration_control,
                time_integration_quantities=["x"],
                time_independent_input_quantities=["b"],
                checkpointing_type=checkpointing_implementation,
                error_controller=test_controller,
                error_estimator_type=test_estimator,
                adaptive_time_stepping=True,
            ),
            promotes=["*"],
        )
    
        runge_kutta_prob.setup()
        runge_kutta_prob["b"] = parameter
        runge_kutta_prob.run_model()
        if checkpointing_implementation == NoCheckpointer:
            with pytest.raises(NotImplementedError):
                runge_kutta_prob.check_partials(excludes=["Jfd","fd","Jfor-Jfd","Jrev-Jfd"])
        else:
            data = runge_kutta_prob.check_partials()
>           assert_check_partials(data)

test_component_test_adaptive.py:517: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = {'rk_integrator': {('x_final', 'b'): {'J_fd': array([[0.01010045]]), 'J_fwd': array([[0.01010044]]), 'J_rev': array([[...), 'abs error': ErrorTuple(forward=6.5673642080099626e-09, reverse=6.5673642080099626e-09, forward_reverse=0.0), ...}}}
atol = 1e-06, rtol = 1e-06

    def assert_check_partials(data, atol=1e-6, rtol=1e-6):
        """
        Raise assertion if any entry from the return from check_partials is above a tolerance.
    
        Parameters
        ----------
        data : dict of dicts of dicts
                First key:
                    is the component name;
                Second key:
                    is the (output, input) tuple of strings;
                Third key:
                    is one of ['rel error', 'abs error', 'magnitude', 'J_fd', 'J_fwd', 'J_rev'];
    
                For 'rel error', 'abs error', 'magnitude' the value is: A tuple containing norms for
                    forward - fd, adjoint - fd, forward - adjoint.
                For 'J_fd', 'J_fwd', 'J_rev' the value is: A numpy array representing the computed
                    Jacobian for the three different methods of computation.
        atol : float
            absolute error. Default is 1e-6.
        rtol : float
            relative error. Default is 1e-6.
        """
        error_string = ''
        absrel_header = 'abs/rel'
        wrt_header = '< output > wrt < variable >'
        norm_value_header = 'norm value'
        len_absrel_width = len(absrel_header)
        norm_types = ['fwd-fd', 'rev-fd', 'fd-rev']
        len_norm_type_width = max(len(s) for s in norm_types)
    
        for comp in data:
            len_wrt_width = len(wrt_header)
            len_norm_width = len(norm_value_header)
            bad_derivs = []
    
            # Find all derivatives whose errors exceed tolerance.
            # Also, size the output to precompute column extents.
            for (var, wrt) in data[comp]:
                pair_data = data[comp][var, wrt]
                for error_type, tolerance in [('abs error', atol), ('rel error', rtol), ]:
                    actual = pair_data[error_type]
                    for error_val, mode in zip(actual, norm_types):
                        in_error = False
    
                        if error_val is None:
                            # Reverse derivatives only computed on matrix free comps.
                            continue
    
                        if not np.isnan(error_val):
                            if not np.allclose(error_val, 0.0, atol=tolerance):
    
                                if error_type == 'rel error' and mode == 'fwd-fd' and \
                                   np.allclose(pair_data['J_fwd'], 0.0, atol=atol) and \
                                   np.allclose(pair_data['J_fd'], 0.0, atol=atol):
                                    # Special case: both fd and fwd are really tiny, so we want to
                                    # ignore the rather large relative errors.
                                    in_error = False
                                else:
                                    # This is a bona-fide error.
                                    in_error = True
    
                        elif error_type == 'abs error' and mode == 'fwd-fd':
                            # Either analytic or approximated derivatives contain a NaN.
                            in_error = True
    
                        if in_error:
                            wrt_string = '{0} wrt {1}'.format(var, wrt)
                            norm_string = '{}'.format(error_val)
                            bad_derivs.append((wrt_string, norm_string, error_type, mode))
                            len_wrt_width = max(len_wrt_width, len(wrt_string))
                            len_norm_width = max(len_norm_width, len(norm_string))
    
            if bad_derivs:
                comp_error_string = ''
                for wrt_string, norm_string, error_type, mode in bad_derivs:
                    err_msg = '{0} | {1} | {2} | {3}'.format(
                        pad_name(wrt_string, len_wrt_width),
                        pad_name(error_type.split()[0], len_absrel_width),
                        pad_name(mode, len_norm_type_width),
                        pad_name(norm_string, len_norm_width)) + '\n'
                    comp_error_string += err_msg
    
                name_header = 'Component: {}\n'.format(comp)
                len_name_header = len(name_header)
                header = len_name_header * '-' + '\n'
                header += name_header
                header += len_name_header * '-' + '\n'
                header += '{0} | {1} | {2} | {3}'.format(
                    pad_name(wrt_header, len_wrt_width),
                    pad_name(absrel_header, len_absrel_width),
                    pad_name('norm', len_norm_type_width),
                    pad_name(norm_value_header, len_norm_width),
                ) + '\n'
                header += '{0} | {1} | {2} | {3}'.format(
                    len_wrt_width * '-',
                    len_absrel_width * '-',
                    len_norm_type_width * '-',
                    len_norm_width * '-',
                ) + '\n'
                comp_error_string = header + comp_error_string
                error_string += comp_error_string
    
        # if error string then raise error with that string
        if error_string:
            header_line1 = 'Assert Check Partials failed for the following Components'
            header_line2 = 'with absolute tolerance = {} and relative tolerance = {}'.format(atol, rtol)
            header_width = max(len(header_line1), len(header_line2))
            header = '\n' + header_width * '=' + '\n'
            header += header_line1 + '\n'
            header += header_line2 + '\n'
            header += header_width * '=' + '\n'
            error_string = header + error_string
>           raise ValueError(error_string)
E           ValueError: 
E           ==============================================================
E           Assert Check Partials failed for the following Components
E           with absolute tolerance = 1e-06 and relative tolerance = 1e-06
E           ==============================================================
E           -------------------------
E           Component: rk_integrator
E           -------------------------
E           < output > wrt < variable > | abs/rel | norm   | norm value            
E           --------------------------- | ------- | ------ | ----------------------
E           x_final wrt b               | rel     | fwd-fd | 1.3225009681181428e-06
E           x_final wrt b               | rel     | rev-fd | 1.3225009681181428e-06

/home/shuv_im/.spack/rev.23.05/install/linux-rocky8-zen2/gcc-10.4.0/py-openmdao-3.9.1-dlr.6-w57zdo/lib/python3.9/site-packages/openmdao/utils/assert_utils.py:225: ValueError
----------------------------- Captured stdout call -----------------------------


Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting fwd-mode jacvec product


Resetting error estimator.


Starting step 1 of fwd-mode jacvec product.
Time = 1.0, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 1.
Starting stage 2 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 1.

Finished step 1 of fwd-mode jacvec product.


Starting step 2 of fwd-mode jacvec product.
Time = 1.001, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 2.
Starting stage 2 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 2.

Finished step 2 of fwd-mode jacvec product.


Starting step 3 of fwd-mode jacvec product.
Time = 1.0024491527342858, dTime = 0.0014491527342858142.

Starting stage 1 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 3.
Starting stage 2 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 3.

Finished step 3 of fwd-mode jacvec product.


Starting step 4 of fwd-mode jacvec product.
Time = 1.0071381905040981, dTime = 0.00468903776981241.

Starting stage 1 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 4.
Starting stage 2 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 4.

Finished step 4 of fwd-mode jacvec product.



Finished fwd-mode jacvec product




Starting fwd-mode jacvec product


Resetting error estimator.


Starting step 1 of fwd-mode jacvec product.
Time = 1.0, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 1.
Starting stage 2 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 1.

Finished step 1 of fwd-mode jacvec product.


Starting step 2 of fwd-mode jacvec product.
Time = 1.001, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 2.
Starting stage 2 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 2.

Finished step 2 of fwd-mode jacvec product.


Starting step 3 of fwd-mode jacvec product.
Time = 1.0024491527342858, dTime = 0.0014491527342858142.

Starting stage 1 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 3.
Starting stage 2 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 3.

Finished step 3 of fwd-mode jacvec product.


Starting step 4 of fwd-mode jacvec product.
Time = 1.0071381905040981, dTime = 0.00468903776981241.

Starting stage 1 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 4.
Starting stage 2 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 4.

Finished step 4 of fwd-mode jacvec product.



Finished fwd-mode jacvec product




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting rev-mode jacvec product



Starting step 4 of rev-mode jacvec product.
Time = 1.0071381905040981, dTime = 0.002861809495901868.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 4.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 4.

Finishing step 4 of rev-mode jacvec product.


Starting step 3 of rev-mode jacvec product.
Time = 1.0024491527342858, dTime = 0.00468903776981241.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 3.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 3.

Finishing step 3 of rev-mode jacvec product.


Starting step 2 of rev-mode jacvec product.
Time = 1.001, dTime = 0.0014491527342858142.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 2.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 2.

Finishing step 2 of rev-mode jacvec product.


Starting step 1 of rev-mode jacvec product.
Time = 1.0, dTime = 0.001.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 1.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 1.

Finishing step 1 of rev-mode jacvec product.



Finished rev-mode jacvec product




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute


-----------------------------------------------
Component: RungeKuttaIntegrator 'rk_integrator'
-----------------------------------------------
  rk_integrator: 'x_final' wrt 'b'
     Forward Magnitude: 1.010044e-02
     Reverse Magnitude: 1.010044e-02
          Fd Magnitude: 1.010045e-02 (fd:forward)
    Absolute Error (Jfor - Jfd) : 1.335785e-08
    Absolute Error (Jrev - Jfd) : 1.335785e-08
    Absolute Error (Jfor - Jrev): 0.000000e+00

    Relative Error (Jfor - Jfd) / Jfd : 1.322501e-06 *
    Relative Error (Jrev - Jfd) / Jfd : 1.322501e-06 *
    Relative Error (Jfor - Jrev) / Jfd: 0.000000e+00

    Raw Forward Derivative (Jfor)
[[0.01010044]]

    Raw Reverse Derivative (Jrev)
[[0.01010044]]

    Raw FD Derivative (Jfd)
[[0.01010045]]

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  rk_integrator: 'x_final' wrt 'x_initial'
     Forward Magnitude: 1.010050e+00
     Reverse Magnitude: 1.010050e+00
          Fd Magnitude: 1.010050e+00 (fd:forward)
    Absolute Error (Jfor - Jfd) : 6.567364e-09
    Absolute Error (Jrev - Jfd) : 6.567364e-09
    Absolute Error (Jfor - Jrev): 0.000000e+00

    Relative Error (Jfor - Jfd) / Jfd : 6.502018e-09
    Relative Error (Jrev - Jfd) / Jfd : 6.502018e-09
    Relative Error (Jfor - Jrev) / Jfd: 0.000000e+00

    Raw Forward Derivative (Jfor)
[[1.01005015]]

    Raw Reverse Derivative (Jrev)
[[1.01005015]]

    Raw FD Derivative (Jfd)
[[1.01005015]]

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
_ test_time_integration_with_parameter_partials[PID-SimpleErrorEstimator-AllCheckpointer-butcher_tableau1-1.0-TestComp1-0.0] _

test_class = <class 'tests.test_components.TestComp1'>, initial_time = 0.0
parameter = 1.0
butcher_tableau = <rkopenmdao.butcher_tableau.EmbeddedButcherTableau object at 0x15551f7d7f40>
checkpointing_implementation = <class 'rkopenmdao.checkpoint_interface.all_checkpointer.AllCheckpointer'>
test_estimator = <class 'rkopenmdao.error_estimator.SimpleErrorEstimator'>
test_controller = <function PID at 0x1555201d5550>

    @pytest.mark.rk
    @pytest.mark.rk_openmdao
    @pytest.mark.parametrize(
        "test_class, initial_time",
        (
            [TestComp1, 0.0],
            [TestComp1, 1.0],
        ),
    )
    @pytest.mark.parametrize("parameter", [1.0])
    @pytest.mark.parametrize(
        "butcher_tableau",
        [
            heun_euler,
            two_stage_dirk,
            three_stage_esdirk,
            four_stage_esdirk,
            five_stage_esdirk
        ]
    )
    @pytest.mark.parametrize(
        "checkpointing_implementation",
        [
            NoCheckpointer,
            AllCheckpointer,
        ],
    )
    @pytest.mark.parametrize(
        "test_estimator",
        [
            SimpleErrorEstimator,
            ImprovedErrorEstimator
        ]
    )
    @pytest.mark.parametrize(
        "test_controller",
        [
            Integral,
            H0_110,
            PID
        ]
    )
    def test_time_integration_with_parameter_partials(
        test_class, initial_time, parameter, butcher_tableau, checkpointing_implementation, test_estimator, test_controller
    ):
        """Tests the partials of the time integration of the different components."""
        termination_criterion = TerminationCriterion('end_time', initial_time + 0.01)
        integration_control = IntegrationControl(initial_time, termination_criterion, 0.001)
        time_integration_prob = om.Problem()
        time_integration_prob.model.add_subsystem(
            "test_comp", test_class(integration_control=integration_control)
        )
    
        time_integration_prob.model.nonlinear_solver = om.NewtonSolver(
            solve_subsystems=True
        )
        time_integration_prob.model.linear_solver = om.ScipyKrylov()
    
        runge_kutta_prob = om.Problem()
        runge_kutta_prob.model.add_subsystem(
            "rk_integrator",
            RungeKuttaIntegrator(
                time_stage_problem=time_integration_prob,
                butcher_tableau=butcher_tableau,
                integration_control=integration_control,
                time_integration_quantities=["x"],
                time_independent_input_quantities=["b"],
                checkpointing_type=checkpointing_implementation,
                error_controller=test_controller,
                error_estimator_type=test_estimator,
                adaptive_time_stepping=True,
            ),
            promotes=["*"],
        )
    
        runge_kutta_prob.setup()
        runge_kutta_prob["b"] = parameter
        runge_kutta_prob.run_model()
        if checkpointing_implementation == NoCheckpointer:
            with pytest.raises(NotImplementedError):
                runge_kutta_prob.check_partials(excludes=["Jfd","fd","Jfor-Jfd","Jrev-Jfd"])
        else:
            data = runge_kutta_prob.check_partials()
>           assert_check_partials(data)

test_component_test_adaptive.py:517: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = {'rk_integrator': {('x_final', 'b'): {'J_fd': array([[0.01008793]]), 'J_fwd': array([[0.01008794]]), 'J_rev': array([[...ErrorTuple(forward=6.086048109921194e-09, reverse=6.086047887876589e-09, forward_reverse=2.220446049250313e-16), ...}}}
atol = 1e-06, rtol = 1e-06

    def assert_check_partials(data, atol=1e-6, rtol=1e-6):
        """
        Raise assertion if any entry from the return from check_partials is above a tolerance.
    
        Parameters
        ----------
        data : dict of dicts of dicts
                First key:
                    is the component name;
                Second key:
                    is the (output, input) tuple of strings;
                Third key:
                    is one of ['rel error', 'abs error', 'magnitude', 'J_fd', 'J_fwd', 'J_rev'];
    
                For 'rel error', 'abs error', 'magnitude' the value is: A tuple containing norms for
                    forward - fd, adjoint - fd, forward - adjoint.
                For 'J_fd', 'J_fwd', 'J_rev' the value is: A numpy array representing the computed
                    Jacobian for the three different methods of computation.
        atol : float
            absolute error. Default is 1e-6.
        rtol : float
            relative error. Default is 1e-6.
        """
        error_string = ''
        absrel_header = 'abs/rel'
        wrt_header = '< output > wrt < variable >'
        norm_value_header = 'norm value'
        len_absrel_width = len(absrel_header)
        norm_types = ['fwd-fd', 'rev-fd', 'fd-rev']
        len_norm_type_width = max(len(s) for s in norm_types)
    
        for comp in data:
            len_wrt_width = len(wrt_header)
            len_norm_width = len(norm_value_header)
            bad_derivs = []
    
            # Find all derivatives whose errors exceed tolerance.
            # Also, size the output to precompute column extents.
            for (var, wrt) in data[comp]:
                pair_data = data[comp][var, wrt]
                for error_type, tolerance in [('abs error', atol), ('rel error', rtol), ]:
                    actual = pair_data[error_type]
                    for error_val, mode in zip(actual, norm_types):
                        in_error = False
    
                        if error_val is None:
                            # Reverse derivatives only computed on matrix free comps.
                            continue
    
                        if not np.isnan(error_val):
                            if not np.allclose(error_val, 0.0, atol=tolerance):
    
                                if error_type == 'rel error' and mode == 'fwd-fd' and \
                                   np.allclose(pair_data['J_fwd'], 0.0, atol=atol) and \
                                   np.allclose(pair_data['J_fd'], 0.0, atol=atol):
                                    # Special case: both fd and fwd are really tiny, so we want to
                                    # ignore the rather large relative errors.
                                    in_error = False
                                else:
                                    # This is a bona-fide error.
                                    in_error = True
    
                        elif error_type == 'abs error' and mode == 'fwd-fd':
                            # Either analytic or approximated derivatives contain a NaN.
                            in_error = True
    
                        if in_error:
                            wrt_string = '{0} wrt {1}'.format(var, wrt)
                            norm_string = '{}'.format(error_val)
                            bad_derivs.append((wrt_string, norm_string, error_type, mode))
                            len_wrt_width = max(len_wrt_width, len(wrt_string))
                            len_norm_width = max(len_norm_width, len(norm_string))
    
            if bad_derivs:
                comp_error_string = ''
                for wrt_string, norm_string, error_type, mode in bad_derivs:
                    err_msg = '{0} | {1} | {2} | {3}'.format(
                        pad_name(wrt_string, len_wrt_width),
                        pad_name(error_type.split()[0], len_absrel_width),
                        pad_name(mode, len_norm_type_width),
                        pad_name(norm_string, len_norm_width)) + '\n'
                    comp_error_string += err_msg
    
                name_header = 'Component: {}\n'.format(comp)
                len_name_header = len(name_header)
                header = len_name_header * '-' + '\n'
                header += name_header
                header += len_name_header * '-' + '\n'
                header += '{0} | {1} | {2} | {3}'.format(
                    pad_name(wrt_header, len_wrt_width),
                    pad_name(absrel_header, len_absrel_width),
                    pad_name('norm', len_norm_type_width),
                    pad_name(norm_value_header, len_norm_width),
                ) + '\n'
                header += '{0} | {1} | {2} | {3}'.format(
                    len_wrt_width * '-',
                    len_absrel_width * '-',
                    len_norm_type_width * '-',
                    len_norm_width * '-',
                ) + '\n'
                comp_error_string = header + comp_error_string
                error_string += comp_error_string
    
        # if error string then raise error with that string
        if error_string:
            header_line1 = 'Assert Check Partials failed for the following Components'
            header_line2 = 'with absolute tolerance = {} and relative tolerance = {}'.format(atol, rtol)
            header_width = max(len(header_line1), len(header_line2))
            header = '\n' + header_width * '=' + '\n'
            header += header_line1 + '\n'
            header += header_line2 + '\n'
            header += header_width * '=' + '\n'
            error_string = header + error_string
>           raise ValueError(error_string)
E           ValueError: 
E           ==============================================================
E           Assert Check Partials failed for the following Components
E           with absolute tolerance = 1e-06 and relative tolerance = 1e-06
E           ==============================================================
E           -------------------------
E           Component: rk_integrator
E           -------------------------
E           < output > wrt < variable > | abs/rel | norm   | norm value           
E           --------------------------- | ------- | ------ | ---------------------
E           x_final wrt b               | rel     | fwd-fd | 1.151655176259822e-06
E           x_final wrt b               | rel     | rev-fd | 1.151655176259822e-06

/home/shuv_im/.spack/rev.23.05/install/linux-rocky8-zen2/gcc-10.4.0/py-openmdao-3.9.1-dlr.6-w57zdo/lib/python3.9/site-packages/openmdao/utils/assert_utils.py:225: ValueError
----------------------------- Captured stdout call -----------------------------


Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting fwd-mode jacvec product


Resetting error estimator.


Starting step 1 of fwd-mode jacvec product.
Time = 0.0, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 1.
Starting stage 2 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 1.

Finished step 1 of fwd-mode jacvec product.


Starting step 2 of fwd-mode jacvec product.
Time = 0.001, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 2.
Starting stage 2 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 2.

Finished step 2 of fwd-mode jacvec product.


Starting step 3 of fwd-mode jacvec product.
Time = 0.0025514124959286075, dTime = 0.0015514124959286073.

Starting stage 1 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 3.
Starting stage 2 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 3.

Finished step 3 of fwd-mode jacvec product.


Starting step 4 of fwd-mode jacvec product.
Time = 0.008664182924716633, dTime = 0.006112770428788026.

Starting stage 1 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 4.
Starting stage 2 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 4.

Finished step 4 of fwd-mode jacvec product.



Finished fwd-mode jacvec product




Starting fwd-mode jacvec product


Resetting error estimator.


Starting step 1 of fwd-mode jacvec product.
Time = 0.0, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 1.
Starting stage 2 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 1.

Finished step 1 of fwd-mode jacvec product.


Starting step 2 of fwd-mode jacvec product.
Time = 0.001, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 2.
Starting stage 2 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 2.

Finished step 2 of fwd-mode jacvec product.


Starting step 3 of fwd-mode jacvec product.
Time = 0.0025514124959286075, dTime = 0.0015514124959286073.

Starting stage 1 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 3.
Starting stage 2 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 3.

Finished step 3 of fwd-mode jacvec product.


Starting step 4 of fwd-mode jacvec product.
Time = 0.008664182924716633, dTime = 0.006112770428788026.

Starting stage 1 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 4.
Starting stage 2 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 4.

Finished step 4 of fwd-mode jacvec product.



Finished fwd-mode jacvec product




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting rev-mode jacvec product



Starting step 4 of rev-mode jacvec product.
Time = 0.008664182924716633, dTime = 0.0013358170752833676.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 4.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 4.

Finishing step 4 of rev-mode jacvec product.


Starting step 3 of rev-mode jacvec product.
Time = 0.0025514124959286075, dTime = 0.006112770428788026.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 3.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 3.

Finishing step 3 of rev-mode jacvec product.


Starting step 2 of rev-mode jacvec product.
Time = 0.001, dTime = 0.0015514124959286073.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 2.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 2.

Finishing step 2 of rev-mode jacvec product.


Starting step 1 of rev-mode jacvec product.
Time = 0.0, dTime = 0.001.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 1.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 1.

Finishing step 1 of rev-mode jacvec product.



Finished rev-mode jacvec product




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute


-----------------------------------------------
Component: RungeKuttaIntegrator 'rk_integrator'
-----------------------------------------------
  rk_integrator: 'x_final' wrt 'b'
     Forward Magnitude: 1.008794e-02
     Reverse Magnitude: 1.008794e-02
          Fd Magnitude: 1.008793e-02 (fd:forward)
    Absolute Error (Jfor - Jfd) : 1.161782e-08
    Absolute Error (Jrev - Jfd) : 1.161782e-08
    Absolute Error (Jfor - Jrev): 0.000000e+00

    Relative Error (Jfor - Jfd) / Jfd : 1.151655e-06 *
    Relative Error (Jrev - Jfd) / Jfd : 1.151655e-06 *
    Relative Error (Jfor - Jrev) / Jfd: 0.000000e+00

    Raw Forward Derivative (Jfor)
[[0.01008794]]

    Raw Reverse Derivative (Jrev)
[[0.01008794]]

    Raw FD Derivative (Jfd)
[[0.01008793]]

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  rk_integrator: 'x_final' wrt 'x_initial'
     Forward Magnitude: 1.010050e+00
     Reverse Magnitude: 1.010050e+00
          Fd Magnitude: 1.010050e+00 (fd:forward)
    Absolute Error (Jfor - Jfd) : 6.086048e-09
    Absolute Error (Jrev - Jfd) : 6.086048e-09
    Absolute Error (Jfor - Jrev): 2.220446e-16

    Relative Error (Jfor - Jfd) / Jfd : 6.025491e-09
    Relative Error (Jrev - Jfd) / Jfd : 6.025491e-09
    Relative Error (Jfor - Jrev) / Jfd: 2.198352e-16

    Raw Forward Derivative (Jfor)
[[1.01005018]]

    Raw Reverse Derivative (Jrev)
[[1.01005018]]

    Raw FD Derivative (Jfd)
[[1.01005017]]

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
_ test_time_integration_with_parameter_partials[PID-SimpleErrorEstimator-AllCheckpointer-butcher_tableau1-1.0-TestComp1-1.0] _

test_class = <class 'tests.test_components.TestComp1'>, initial_time = 1.0
parameter = 1.0
butcher_tableau = <rkopenmdao.butcher_tableau.EmbeddedButcherTableau object at 0x15551f7d7f40>
checkpointing_implementation = <class 'rkopenmdao.checkpoint_interface.all_checkpointer.AllCheckpointer'>
test_estimator = <class 'rkopenmdao.error_estimator.SimpleErrorEstimator'>
test_controller = <function PID at 0x1555201d5550>

    @pytest.mark.rk
    @pytest.mark.rk_openmdao
    @pytest.mark.parametrize(
        "test_class, initial_time",
        (
            [TestComp1, 0.0],
            [TestComp1, 1.0],
        ),
    )
    @pytest.mark.parametrize("parameter", [1.0])
    @pytest.mark.parametrize(
        "butcher_tableau",
        [
            heun_euler,
            two_stage_dirk,
            three_stage_esdirk,
            four_stage_esdirk,
            five_stage_esdirk
        ]
    )
    @pytest.mark.parametrize(
        "checkpointing_implementation",
        [
            NoCheckpointer,
            AllCheckpointer,
        ],
    )
    @pytest.mark.parametrize(
        "test_estimator",
        [
            SimpleErrorEstimator,
            ImprovedErrorEstimator
        ]
    )
    @pytest.mark.parametrize(
        "test_controller",
        [
            Integral,
            H0_110,
            PID
        ]
    )
    def test_time_integration_with_parameter_partials(
        test_class, initial_time, parameter, butcher_tableau, checkpointing_implementation, test_estimator, test_controller
    ):
        """Tests the partials of the time integration of the different components."""
        termination_criterion = TerminationCriterion('end_time', initial_time + 0.01)
        integration_control = IntegrationControl(initial_time, termination_criterion, 0.001)
        time_integration_prob = om.Problem()
        time_integration_prob.model.add_subsystem(
            "test_comp", test_class(integration_control=integration_control)
        )
    
        time_integration_prob.model.nonlinear_solver = om.NewtonSolver(
            solve_subsystems=True
        )
        time_integration_prob.model.linear_solver = om.ScipyKrylov()
    
        runge_kutta_prob = om.Problem()
        runge_kutta_prob.model.add_subsystem(
            "rk_integrator",
            RungeKuttaIntegrator(
                time_stage_problem=time_integration_prob,
                butcher_tableau=butcher_tableau,
                integration_control=integration_control,
                time_integration_quantities=["x"],
                time_independent_input_quantities=["b"],
                checkpointing_type=checkpointing_implementation,
                error_controller=test_controller,
                error_estimator_type=test_estimator,
                adaptive_time_stepping=True,
            ),
            promotes=["*"],
        )
    
        runge_kutta_prob.setup()
        runge_kutta_prob["b"] = parameter
        runge_kutta_prob.run_model()
        if checkpointing_implementation == NoCheckpointer:
            with pytest.raises(NotImplementedError):
                runge_kutta_prob.check_partials(excludes=["Jfd","fd","Jfor-Jfd","Jrev-Jfd"])
        else:
            data = runge_kutta_prob.check_partials()
>           assert_check_partials(data)

test_component_test_adaptive.py:517: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = {'rk_integrator': {('x_final', 'b'): {'J_fd': array([[0.01008793]]), 'J_fwd': array([[0.01008794]]), 'J_rev': array([[...: ErrorTuple(forward=6.30809293689083e-09, reverse=6.30809249280162e-09, forward_reverse=4.440892098500626e-16), ...}}}
atol = 1e-06, rtol = 1e-06

    def assert_check_partials(data, atol=1e-6, rtol=1e-6):
        """
        Raise assertion if any entry from the return from check_partials is above a tolerance.
    
        Parameters
        ----------
        data : dict of dicts of dicts
                First key:
                    is the component name;
                Second key:
                    is the (output, input) tuple of strings;
                Third key:
                    is one of ['rel error', 'abs error', 'magnitude', 'J_fd', 'J_fwd', 'J_rev'];
    
                For 'rel error', 'abs error', 'magnitude' the value is: A tuple containing norms for
                    forward - fd, adjoint - fd, forward - adjoint.
                For 'J_fd', 'J_fwd', 'J_rev' the value is: A numpy array representing the computed
                    Jacobian for the three different methods of computation.
        atol : float
            absolute error. Default is 1e-6.
        rtol : float
            relative error. Default is 1e-6.
        """
        error_string = ''
        absrel_header = 'abs/rel'
        wrt_header = '< output > wrt < variable >'
        norm_value_header = 'norm value'
        len_absrel_width = len(absrel_header)
        norm_types = ['fwd-fd', 'rev-fd', 'fd-rev']
        len_norm_type_width = max(len(s) for s in norm_types)
    
        for comp in data:
            len_wrt_width = len(wrt_header)
            len_norm_width = len(norm_value_header)
            bad_derivs = []
    
            # Find all derivatives whose errors exceed tolerance.
            # Also, size the output to precompute column extents.
            for (var, wrt) in data[comp]:
                pair_data = data[comp][var, wrt]
                for error_type, tolerance in [('abs error', atol), ('rel error', rtol), ]:
                    actual = pair_data[error_type]
                    for error_val, mode in zip(actual, norm_types):
                        in_error = False
    
                        if error_val is None:
                            # Reverse derivatives only computed on matrix free comps.
                            continue
    
                        if not np.isnan(error_val):
                            if not np.allclose(error_val, 0.0, atol=tolerance):
    
                                if error_type == 'rel error' and mode == 'fwd-fd' and \
                                   np.allclose(pair_data['J_fwd'], 0.0, atol=atol) and \
                                   np.allclose(pair_data['J_fd'], 0.0, atol=atol):
                                    # Special case: both fd and fwd are really tiny, so we want to
                                    # ignore the rather large relative errors.
                                    in_error = False
                                else:
                                    # This is a bona-fide error.
                                    in_error = True
    
                        elif error_type == 'abs error' and mode == 'fwd-fd':
                            # Either analytic or approximated derivatives contain a NaN.
                            in_error = True
    
                        if in_error:
                            wrt_string = '{0} wrt {1}'.format(var, wrt)
                            norm_string = '{}'.format(error_val)
                            bad_derivs.append((wrt_string, norm_string, error_type, mode))
                            len_wrt_width = max(len_wrt_width, len(wrt_string))
                            len_norm_width = max(len_norm_width, len(norm_string))
    
            if bad_derivs:
                comp_error_string = ''
                for wrt_string, norm_string, error_type, mode in bad_derivs:
                    err_msg = '{0} | {1} | {2} | {3}'.format(
                        pad_name(wrt_string, len_wrt_width),
                        pad_name(error_type.split()[0], len_absrel_width),
                        pad_name(mode, len_norm_type_width),
                        pad_name(norm_string, len_norm_width)) + '\n'
                    comp_error_string += err_msg
    
                name_header = 'Component: {}\n'.format(comp)
                len_name_header = len(name_header)
                header = len_name_header * '-' + '\n'
                header += name_header
                header += len_name_header * '-' + '\n'
                header += '{0} | {1} | {2} | {3}'.format(
                    pad_name(wrt_header, len_wrt_width),
                    pad_name(absrel_header, len_absrel_width),
                    pad_name('norm', len_norm_type_width),
                    pad_name(norm_value_header, len_norm_width),
                ) + '\n'
                header += '{0} | {1} | {2} | {3}'.format(
                    len_wrt_width * '-',
                    len_absrel_width * '-',
                    len_norm_type_width * '-',
                    len_norm_width * '-',
                ) + '\n'
                comp_error_string = header + comp_error_string
                error_string += comp_error_string
    
        # if error string then raise error with that string
        if error_string:
            header_line1 = 'Assert Check Partials failed for the following Components'
            header_line2 = 'with absolute tolerance = {} and relative tolerance = {}'.format(atol, rtol)
            header_width = max(len(header_line1), len(header_line2))
            header = '\n' + header_width * '=' + '\n'
            header += header_line1 + '\n'
            header += header_line2 + '\n'
            header += header_width * '=' + '\n'
            error_string = header + error_string
>           raise ValueError(error_string)
E           ValueError: 
E           ==============================================================
E           Assert Check Partials failed for the following Components
E           with absolute tolerance = 1e-06 and relative tolerance = 1e-06
E           ==============================================================
E           -------------------------
E           Component: rk_integrator
E           -------------------------
E           < output > wrt < variable > | abs/rel | norm   | norm value            
E           --------------------------- | ------- | ------ | ----------------------
E           x_final wrt b               | rel     | fwd-fd | 1.1736661380322043e-06
E           x_final wrt b               | rel     | rev-fd | 1.1736661380322043e-06

/home/shuv_im/.spack/rev.23.05/install/linux-rocky8-zen2/gcc-10.4.0/py-openmdao-3.9.1-dlr.6-w57zdo/lib/python3.9/site-packages/openmdao/utils/assert_utils.py:225: ValueError
----------------------------- Captured stdout call -----------------------------


Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting fwd-mode jacvec product


Resetting error estimator.


Starting step 1 of fwd-mode jacvec product.
Time = 1.0, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 1.
Starting stage 2 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 1.

Finished step 1 of fwd-mode jacvec product.


Starting step 2 of fwd-mode jacvec product.
Time = 1.001, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 2.
Starting stage 2 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 2.

Finished step 2 of fwd-mode jacvec product.


Starting step 3 of fwd-mode jacvec product.
Time = 1.0025514124959285, dTime = 0.0015514124959286073.

Starting stage 1 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 3.
Starting stage 2 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 3.

Finished step 3 of fwd-mode jacvec product.


Starting step 4 of fwd-mode jacvec product.
Time = 1.0086641829247165, dTime = 0.006112770428788026.

Starting stage 1 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 4.
Starting stage 2 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 4.

Finished step 4 of fwd-mode jacvec product.



Finished fwd-mode jacvec product




Starting fwd-mode jacvec product


Resetting error estimator.


Starting step 1 of fwd-mode jacvec product.
Time = 1.0, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 1.
Starting stage 2 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 1.

Finished step 1 of fwd-mode jacvec product.


Starting step 2 of fwd-mode jacvec product.
Time = 1.001, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 2.
Starting stage 2 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 2.

Finished step 2 of fwd-mode jacvec product.


Starting step 3 of fwd-mode jacvec product.
Time = 1.0025514124959285, dTime = 0.0015514124959286073.

Starting stage 1 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 3.
Starting stage 2 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 3.

Finished step 3 of fwd-mode jacvec product.


Starting step 4 of fwd-mode jacvec product.
Time = 1.0086641829247165, dTime = 0.006112770428788026.

Starting stage 1 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 4.
Starting stage 2 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 4.

Finished step 4 of fwd-mode jacvec product.



Finished fwd-mode jacvec product




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting rev-mode jacvec product



Starting step 4 of rev-mode jacvec product.
Time = 1.0086641829247165, dTime = 0.0013358170752835186.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 4.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 4.

Finishing step 4 of rev-mode jacvec product.


Starting step 3 of rev-mode jacvec product.
Time = 1.0025514124959285, dTime = 0.006112770428788026.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 3.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 3.

Finishing step 3 of rev-mode jacvec product.


Starting step 2 of rev-mode jacvec product.
Time = 1.001, dTime = 0.0015514124959286073.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 2.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 2.

Finishing step 2 of rev-mode jacvec product.


Starting step 1 of rev-mode jacvec product.
Time = 1.0, dTime = 0.001.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 1.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 1.

Finishing step 1 of rev-mode jacvec product.



Finished rev-mode jacvec product




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute


-----------------------------------------------
Component: RungeKuttaIntegrator 'rk_integrator'
-----------------------------------------------
  rk_integrator: 'x_final' wrt 'b'
     Forward Magnitude: 1.008794e-02
     Reverse Magnitude: 1.008794e-02
          Fd Magnitude: 1.008793e-02 (fd:forward)
    Absolute Error (Jfor - Jfd) : 1.183986e-08
    Absolute Error (Jrev - Jfd) : 1.183986e-08
    Absolute Error (Jfor - Jrev): 0.000000e+00

    Relative Error (Jfor - Jfd) / Jfd : 1.173666e-06 *
    Relative Error (Jrev - Jfd) / Jfd : 1.173666e-06 *
    Relative Error (Jfor - Jrev) / Jfd: 0.000000e+00

    Raw Forward Derivative (Jfor)
[[0.01008794]]

    Raw Reverse Derivative (Jrev)
[[0.01008794]]

    Raw FD Derivative (Jfd)
[[0.01008793]]

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  rk_integrator: 'x_final' wrt 'x_initial'
     Forward Magnitude: 1.010050e+00
     Reverse Magnitude: 1.010050e+00
          Fd Magnitude: 1.010050e+00 (fd:forward)
    Absolute Error (Jfor - Jfd) : 6.308093e-09
    Absolute Error (Jrev - Jfd) : 6.308092e-09
    Absolute Error (Jfor - Jrev): 4.440892e-16

    Relative Error (Jfor - Jfd) / Jfd : 6.245326e-09
    Relative Error (Jrev - Jfd) / Jfd : 6.245326e-09
    Relative Error (Jfor - Jrev) / Jfd: 4.396704e-16

    Raw Forward Derivative (Jfor)
[[1.01005018]]

    Raw Reverse Derivative (Jrev)
[[1.01005018]]

    Raw FD Derivative (Jfd)
[[1.01005017]]

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
_ test_time_integration_with_parameter_partials[PID-SimpleErrorEstimator-AllCheckpointer-butcher_tableau3-1.0-TestComp1-0.0] _

test_class = <class 'tests.test_components.TestComp1'>, initial_time = 0.0
parameter = 1.0
butcher_tableau = <rkopenmdao.butcher_tableau.EmbeddedButcherTableau object at 0x15551f7d7fd0>
checkpointing_implementation = <class 'rkopenmdao.checkpoint_interface.all_checkpointer.AllCheckpointer'>
test_estimator = <class 'rkopenmdao.error_estimator.SimpleErrorEstimator'>
test_controller = <function PID at 0x1555201d5550>

    @pytest.mark.rk
    @pytest.mark.rk_openmdao
    @pytest.mark.parametrize(
        "test_class, initial_time",
        (
            [TestComp1, 0.0],
            [TestComp1, 1.0],
        ),
    )
    @pytest.mark.parametrize("parameter", [1.0])
    @pytest.mark.parametrize(
        "butcher_tableau",
        [
            heun_euler,
            two_stage_dirk,
            three_stage_esdirk,
            four_stage_esdirk,
            five_stage_esdirk
        ]
    )
    @pytest.mark.parametrize(
        "checkpointing_implementation",
        [
            NoCheckpointer,
            AllCheckpointer,
        ],
    )
    @pytest.mark.parametrize(
        "test_estimator",
        [
            SimpleErrorEstimator,
            ImprovedErrorEstimator
        ]
    )
    @pytest.mark.parametrize(
        "test_controller",
        [
            Integral,
            H0_110,
            PID
        ]
    )
    def test_time_integration_with_parameter_partials(
        test_class, initial_time, parameter, butcher_tableau, checkpointing_implementation, test_estimator, test_controller
    ):
        """Tests the partials of the time integration of the different components."""
        termination_criterion = TerminationCriterion('end_time', initial_time + 0.01)
        integration_control = IntegrationControl(initial_time, termination_criterion, 0.001)
        time_integration_prob = om.Problem()
        time_integration_prob.model.add_subsystem(
            "test_comp", test_class(integration_control=integration_control)
        )
    
        time_integration_prob.model.nonlinear_solver = om.NewtonSolver(
            solve_subsystems=True
        )
        time_integration_prob.model.linear_solver = om.ScipyKrylov()
    
        runge_kutta_prob = om.Problem()
        runge_kutta_prob.model.add_subsystem(
            "rk_integrator",
            RungeKuttaIntegrator(
                time_stage_problem=time_integration_prob,
                butcher_tableau=butcher_tableau,
                integration_control=integration_control,
                time_integration_quantities=["x"],
                time_independent_input_quantities=["b"],
                checkpointing_type=checkpointing_implementation,
                error_controller=test_controller,
                error_estimator_type=test_estimator,
                adaptive_time_stepping=True,
            ),
            promotes=["*"],
        )
    
        runge_kutta_prob.setup()
        runge_kutta_prob["b"] = parameter
        runge_kutta_prob.run_model()
        if checkpointing_implementation == NoCheckpointer:
            with pytest.raises(NotImplementedError):
                runge_kutta_prob.check_partials(excludes=["Jfd","fd","Jfor-Jfd","Jrev-Jfd"])
        else:
            data = runge_kutta_prob.check_partials()
>           assert_check_partials(data)

test_component_test_adaptive.py:517: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = {'rk_integrator': {('x_final', 'b'): {'J_fd': array([[0.0100847]]), 'J_fwd': array([[0.01008467]]), 'J_rev': array([[0...rrorTuple(forward=1.823652340249282e-11, reverse=1.8236745447097746e-11, forward_reverse=2.220446049250313e-16), ...}}}
atol = 1e-06, rtol = 1e-06

    def assert_check_partials(data, atol=1e-6, rtol=1e-6):
        """
        Raise assertion if any entry from the return from check_partials is above a tolerance.
    
        Parameters
        ----------
        data : dict of dicts of dicts
                First key:
                    is the component name;
                Second key:
                    is the (output, input) tuple of strings;
                Third key:
                    is one of ['rel error', 'abs error', 'magnitude', 'J_fd', 'J_fwd', 'J_rev'];
    
                For 'rel error', 'abs error', 'magnitude' the value is: A tuple containing norms for
                    forward - fd, adjoint - fd, forward - adjoint.
                For 'J_fd', 'J_fwd', 'J_rev' the value is: A numpy array representing the computed
                    Jacobian for the three different methods of computation.
        atol : float
            absolute error. Default is 1e-6.
        rtol : float
            relative error. Default is 1e-6.
        """
        error_string = ''
        absrel_header = 'abs/rel'
        wrt_header = '< output > wrt < variable >'
        norm_value_header = 'norm value'
        len_absrel_width = len(absrel_header)
        norm_types = ['fwd-fd', 'rev-fd', 'fd-rev']
        len_norm_type_width = max(len(s) for s in norm_types)
    
        for comp in data:
            len_wrt_width = len(wrt_header)
            len_norm_width = len(norm_value_header)
            bad_derivs = []
    
            # Find all derivatives whose errors exceed tolerance.
            # Also, size the output to precompute column extents.
            for (var, wrt) in data[comp]:
                pair_data = data[comp][var, wrt]
                for error_type, tolerance in [('abs error', atol), ('rel error', rtol), ]:
                    actual = pair_data[error_type]
                    for error_val, mode in zip(actual, norm_types):
                        in_error = False
    
                        if error_val is None:
                            # Reverse derivatives only computed on matrix free comps.
                            continue
    
                        if not np.isnan(error_val):
                            if not np.allclose(error_val, 0.0, atol=tolerance):
    
                                if error_type == 'rel error' and mode == 'fwd-fd' and \
                                   np.allclose(pair_data['J_fwd'], 0.0, atol=atol) and \
                                   np.allclose(pair_data['J_fd'], 0.0, atol=atol):
                                    # Special case: both fd and fwd are really tiny, so we want to
                                    # ignore the rather large relative errors.
                                    in_error = False
                                else:
                                    # This is a bona-fide error.
                                    in_error = True
    
                        elif error_type == 'abs error' and mode == 'fwd-fd':
                            # Either analytic or approximated derivatives contain a NaN.
                            in_error = True
    
                        if in_error:
                            wrt_string = '{0} wrt {1}'.format(var, wrt)
                            norm_string = '{}'.format(error_val)
                            bad_derivs.append((wrt_string, norm_string, error_type, mode))
                            len_wrt_width = max(len_wrt_width, len(wrt_string))
                            len_norm_width = max(len_norm_width, len(norm_string))
    
            if bad_derivs:
                comp_error_string = ''
                for wrt_string, norm_string, error_type, mode in bad_derivs:
                    err_msg = '{0} | {1} | {2} | {3}'.format(
                        pad_name(wrt_string, len_wrt_width),
                        pad_name(error_type.split()[0], len_absrel_width),
                        pad_name(mode, len_norm_type_width),
                        pad_name(norm_string, len_norm_width)) + '\n'
                    comp_error_string += err_msg
    
                name_header = 'Component: {}\n'.format(comp)
                len_name_header = len(name_header)
                header = len_name_header * '-' + '\n'
                header += name_header
                header += len_name_header * '-' + '\n'
                header += '{0} | {1} | {2} | {3}'.format(
                    pad_name(wrt_header, len_wrt_width),
                    pad_name(absrel_header, len_absrel_width),
                    pad_name('norm', len_norm_type_width),
                    pad_name(norm_value_header, len_norm_width),
                ) + '\n'
                header += '{0} | {1} | {2} | {3}'.format(
                    len_wrt_width * '-',
                    len_absrel_width * '-',
                    len_norm_type_width * '-',
                    len_norm_width * '-',
                ) + '\n'
                comp_error_string = header + comp_error_string
                error_string += comp_error_string
    
        # if error string then raise error with that string
        if error_string:
            header_line1 = 'Assert Check Partials failed for the following Components'
            header_line2 = 'with absolute tolerance = {} and relative tolerance = {}'.format(atol, rtol)
            header_width = max(len(header_line1), len(header_line2))
            header = '\n' + header_width * '=' + '\n'
            header += header_line1 + '\n'
            header += header_line2 + '\n'
            header += header_width * '=' + '\n'
            error_string = header + error_string
>           raise ValueError(error_string)
E           ValueError: 
E           ==============================================================
E           Assert Check Partials failed for the following Components
E           with absolute tolerance = 1e-06 and relative tolerance = 1e-06
E           ==============================================================
E           -------------------------
E           Component: rk_integrator
E           -------------------------
E           < output > wrt < variable > | abs/rel | norm   | norm value           
E           --------------------------- | ------- | ------ | ---------------------
E           x_final wrt b               | rel     | fwd-fd | 3.458365226518502e-06
E           x_final wrt b               | rel     | rev-fd | 3.458365226346487e-06

/home/shuv_im/.spack/rev.23.05/install/linux-rocky8-zen2/gcc-10.4.0/py-openmdao-3.9.1-dlr.6-w57zdo/lib/python3.9/site-packages/openmdao/utils/assert_utils.py:225: ValueError
----------------------------- Captured stdout call -----------------------------


Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting fwd-mode jacvec product


Resetting error estimator.


Starting step 1 of fwd-mode jacvec product.
Time = 0.0, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 1.
Starting stage 2 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 1.
Starting stage 3 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 1.
Starting stage 4 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 1.

Finished step 1 of fwd-mode jacvec product.


Starting step 2 of fwd-mode jacvec product.
Time = 0.001, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 2.
Starting stage 2 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 2.
Starting stage 3 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 2.
Starting stage 4 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 2.

Finished step 2 of fwd-mode jacvec product.


Starting step 3 of fwd-mode jacvec product.
Time = 0.0025588641016579834, dTime = 0.0015588641016579831.

Starting stage 1 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 3.
Starting stage 2 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 3.
Starting stage 3 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 3.
Starting stage 4 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 3.

Finished step 3 of fwd-mode jacvec product.


Starting step 4 of fwd-mode jacvec product.
Time = 0.008864045502926673, dTime = 0.006305181401268689.

Starting stage 1 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 4.
Starting stage 2 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 4.
Starting stage 3 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 4.
Starting stage 4 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 4.

Finished step 4 of fwd-mode jacvec product.



Finished fwd-mode jacvec product




Starting fwd-mode jacvec product


Resetting error estimator.


Starting step 1 of fwd-mode jacvec product.
Time = 0.0, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 1.
Starting stage 2 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 1.
Starting stage 3 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 1.
Starting stage 4 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 1.

Finished step 1 of fwd-mode jacvec product.


Starting step 2 of fwd-mode jacvec product.
Time = 0.001, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 2.
Starting stage 2 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 2.
Starting stage 3 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 2.
Starting stage 4 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 2.

Finished step 2 of fwd-mode jacvec product.


Starting step 3 of fwd-mode jacvec product.
Time = 0.0025588641016579834, dTime = 0.0015588641016579831.

Starting stage 1 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 3.
Starting stage 2 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 3.
Starting stage 3 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 3.
Starting stage 4 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 3.

Finished step 3 of fwd-mode jacvec product.


Starting step 4 of fwd-mode jacvec product.
Time = 0.008864045502926673, dTime = 0.006305181401268689.

Starting stage 1 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 4.
Starting stage 2 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 4.
Starting stage 3 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 4.
Starting stage 4 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 4.

Finished step 4 of fwd-mode jacvec product.



Finished fwd-mode jacvec product




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting rev-mode jacvec product



Starting step 4 of rev-mode jacvec product.
Time = 0.008864045502926673, dTime = 0.0011359544970733267.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 3 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Finished stage 3 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 4 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.
Finished stage 4 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 4 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 4 of the rev iteration of reve-mode jvp in
step 4.
Starting stage 3 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 3 of the rev iteration of reve-mode jvp in
step 4.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 4.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 4.

Finishing step 4 of rev-mode jacvec product.


Starting step 3 of rev-mode jacvec product.
Time = 0.0025588641016579834, dTime = 0.006305181401268689.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 3 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Finished stage 3 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 4 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.
Finished stage 4 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 4 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 4 of the rev iteration of reve-mode jvp in
step 3.
Starting stage 3 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 3 of the rev iteration of reve-mode jvp in
step 3.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 3.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 3.

Finishing step 3 of rev-mode jacvec product.


Starting step 2 of rev-mode jacvec product.
Time = 0.001, dTime = 0.0015588641016579831.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 3 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Finished stage 3 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 4 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.
Finished stage 4 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 4 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 4 of the rev iteration of reve-mode jvp in
step 2.
Starting stage 3 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 3 of the rev iteration of reve-mode jvp in
step 2.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 2.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 2.

Finishing step 2 of rev-mode jacvec product.


Starting step 1 of rev-mode jacvec product.
Time = 0.0, dTime = 0.001.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 3 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Finished stage 3 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 4 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.
Finished stage 4 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 4 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 4 of the rev iteration of reve-mode jvp in
step 1.
Starting stage 3 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 3 of the rev iteration of reve-mode jvp in
step 1.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 1.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 1.

Finishing step 1 of rev-mode jacvec product.



Finished rev-mode jacvec product




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.

Finishing step 4 of compute.



Finishing compute


-----------------------------------------------
Component: RungeKuttaIntegrator 'rk_integrator'
-----------------------------------------------
  rk_integrator: 'x_final' wrt 'b'
     Forward Magnitude: 1.008467e-02
     Reverse Magnitude: 1.008467e-02
          Fd Magnitude: 1.008470e-02 (fd:forward)
    Absolute Error (Jfor - Jfd) : 3.487659e-08
    Absolute Error (Jrev - Jfd) : 3.487659e-08
    Absolute Error (Jfor - Jrev): 1.734723e-18

    Relative Error (Jfor - Jfd) / Jfd : 3.458365e-06 *
    Relative Error (Jrev - Jfd) / Jfd : 3.458365e-06 *
    Relative Error (Jfor - Jrev) / Jfd: 1.720153e-16

    Raw Forward Derivative (Jfor)
[[0.01008467]]

    Raw Reverse Derivative (Jrev)
[[0.01008467]]

    Raw FD Derivative (Jfd)
[[0.0100847]]

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  rk_integrator: 'x_final' wrt 'x_initial'
     Forward Magnitude: 1.010050e+00
     Reverse Magnitude: 1.010050e+00
          Fd Magnitude: 1.010050e+00 (fd:forward)
    Absolute Error (Jfor - Jfd) : 1.823652e-11
    Absolute Error (Jrev - Jfd) : 1.823675e-11
    Absolute Error (Jfor - Jrev): 2.220446e-16

    Relative Error (Jfor - Jfd) / Jfd : 1.805507e-11
    Relative Error (Jrev - Jfd) / Jfd : 1.805529e-11
    Relative Error (Jfor - Jrev) / Jfd: 2.198352e-16

    Raw Forward Derivative (Jfor)
[[1.01005017]]

    Raw Reverse Derivative (Jrev)
[[1.01005017]]

    Raw FD Derivative (Jfd)
[[1.01005017]]

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
_ test_time_integration_with_parameter_partials[PID-SimpleErrorEstimator-AllCheckpointer-butcher_tableau3-1.0-TestComp1-1.0] _

test_class = <class 'tests.test_components.TestComp1'>, initial_time = 1.0
parameter = 1.0
butcher_tableau = <rkopenmdao.butcher_tableau.EmbeddedButcherTableau object at 0x15551f7d7fd0>
checkpointing_implementation = <class 'rkopenmdao.checkpoint_interface.all_checkpointer.AllCheckpointer'>
test_estimator = <class 'rkopenmdao.error_estimator.SimpleErrorEstimator'>
test_controller = <function PID at 0x1555201d5550>

    @pytest.mark.rk
    @pytest.mark.rk_openmdao
    @pytest.mark.parametrize(
        "test_class, initial_time",
        (
            [TestComp1, 0.0],
            [TestComp1, 1.0],
        ),
    )
    @pytest.mark.parametrize("parameter", [1.0])
    @pytest.mark.parametrize(
        "butcher_tableau",
        [
            heun_euler,
            two_stage_dirk,
            three_stage_esdirk,
            four_stage_esdirk,
            five_stage_esdirk
        ]
    )
    @pytest.mark.parametrize(
        "checkpointing_implementation",
        [
            NoCheckpointer,
            AllCheckpointer,
        ],
    )
    @pytest.mark.parametrize(
        "test_estimator",
        [
            SimpleErrorEstimator,
            ImprovedErrorEstimator
        ]
    )
    @pytest.mark.parametrize(
        "test_controller",
        [
            Integral,
            H0_110,
            PID
        ]
    )
    def test_time_integration_with_parameter_partials(
        test_class, initial_time, parameter, butcher_tableau, checkpointing_implementation, test_estimator, test_controller
    ):
        """Tests the partials of the time integration of the different components."""
        termination_criterion = TerminationCriterion('end_time', initial_time + 0.01)
        integration_control = IntegrationControl(initial_time, termination_criterion, 0.001)
        time_integration_prob = om.Problem()
        time_integration_prob.model.add_subsystem(
            "test_comp", test_class(integration_control=integration_control)
        )
    
        time_integration_prob.model.nonlinear_solver = om.NewtonSolver(
            solve_subsystems=True
        )
        time_integration_prob.model.linear_solver = om.ScipyKrylov()
    
        runge_kutta_prob = om.Problem()
        runge_kutta_prob.model.add_subsystem(
            "rk_integrator",
            RungeKuttaIntegrator(
                time_stage_problem=time_integration_prob,
                butcher_tableau=butcher_tableau,
                integration_control=integration_control,
                time_integration_quantities=["x"],
                time_independent_input_quantities=["b"],
                checkpointing_type=checkpointing_implementation,
                error_controller=test_controller,
                error_estimator_type=test_estimator,
                adaptive_time_stepping=True,
            ),
            promotes=["*"],
        )
    
        runge_kutta_prob.setup()
        runge_kutta_prob["b"] = parameter
        runge_kutta_prob.run_model()
        if checkpointing_implementation == NoCheckpointer:
            with pytest.raises(NotImplementedError):
                runge_kutta_prob.check_partials(excludes=["Jfd","fd","Jfor-Jfd","Jrev-Jfd"])
        else:
            data = runge_kutta_prob.check_partials()
>           assert_check_partials(data)

test_component_test_adaptive.py:517: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = {'rk_integrator': {('x_final', 'b'): {'J_fd': array([[0.0100847]]), 'J_fwd': array([[0.01008467]]), 'J_rev': array([[0...rrorTuple(forward=1.823652340249282e-11, reverse=1.8236745447097746e-11, forward_reverse=2.220446049250313e-16), ...}}}
atol = 1e-06, rtol = 1e-06

    def assert_check_partials(data, atol=1e-6, rtol=1e-6):
        """
        Raise assertion if any entry from the return from check_partials is above a tolerance.
    
        Parameters
        ----------
        data : dict of dicts of dicts
                First key:
                    is the component name;
                Second key:
                    is the (output, input) tuple of strings;
                Third key:
                    is one of ['rel error', 'abs error', 'magnitude', 'J_fd', 'J_fwd', 'J_rev'];
    
                For 'rel error', 'abs error', 'magnitude' the value is: A tuple containing norms for
                    forward - fd, adjoint - fd, forward - adjoint.
                For 'J_fd', 'J_fwd', 'J_rev' the value is: A numpy array representing the computed
                    Jacobian for the three different methods of computation.
        atol : float
            absolute error. Default is 1e-6.
        rtol : float
            relative error. Default is 1e-6.
        """
        error_string = ''
        absrel_header = 'abs/rel'
        wrt_header = '< output > wrt < variable >'
        norm_value_header = 'norm value'
        len_absrel_width = len(absrel_header)
        norm_types = ['fwd-fd', 'rev-fd', 'fd-rev']
        len_norm_type_width = max(len(s) for s in norm_types)
    
        for comp in data:
            len_wrt_width = len(wrt_header)
            len_norm_width = len(norm_value_header)
            bad_derivs = []
    
            # Find all derivatives whose errors exceed tolerance.
            # Also, size the output to precompute column extents.
            for (var, wrt) in data[comp]:
                pair_data = data[comp][var, wrt]
                for error_type, tolerance in [('abs error', atol), ('rel error', rtol), ]:
                    actual = pair_data[error_type]
                    for error_val, mode in zip(actual, norm_types):
                        in_error = False
    
                        if error_val is None:
                            # Reverse derivatives only computed on matrix free comps.
                            continue
    
                        if not np.isnan(error_val):
                            if not np.allclose(error_val, 0.0, atol=tolerance):
    
                                if error_type == 'rel error' and mode == 'fwd-fd' and \
                                   np.allclose(pair_data['J_fwd'], 0.0, atol=atol) and \
                                   np.allclose(pair_data['J_fd'], 0.0, atol=atol):
                                    # Special case: both fd and fwd are really tiny, so we want to
                                    # ignore the rather large relative errors.
                                    in_error = False
                                else:
                                    # This is a bona-fide error.
                                    in_error = True
    
                        elif error_type == 'abs error' and mode == 'fwd-fd':
                            # Either analytic or approximated derivatives contain a NaN.
                            in_error = True
    
                        if in_error:
                            wrt_string = '{0} wrt {1}'.format(var, wrt)
                            norm_string = '{}'.format(error_val)
                            bad_derivs.append((wrt_string, norm_string, error_type, mode))
                            len_wrt_width = max(len_wrt_width, len(wrt_string))
                            len_norm_width = max(len_norm_width, len(norm_string))
    
            if bad_derivs:
                comp_error_string = ''
                for wrt_string, norm_string, error_type, mode in bad_derivs:
                    err_msg = '{0} | {1} | {2} | {3}'.format(
                        pad_name(wrt_string, len_wrt_width),
                        pad_name(error_type.split()[0], len_absrel_width),
                        pad_name(mode, len_norm_type_width),
                        pad_name(norm_string, len_norm_width)) + '\n'
                    comp_error_string += err_msg
    
                name_header = 'Component: {}\n'.format(comp)
                len_name_header = len(name_header)
                header = len_name_header * '-' + '\n'
                header += name_header
                header += len_name_header * '-' + '\n'
                header += '{0} | {1} | {2} | {3}'.format(
                    pad_name(wrt_header, len_wrt_width),
                    pad_name(absrel_header, len_absrel_width),
                    pad_name('norm', len_norm_type_width),
                    pad_name(norm_value_header, len_norm_width),
                ) + '\n'
                header += '{0} | {1} | {2} | {3}'.format(
                    len_wrt_width * '-',
                    len_absrel_width * '-',
                    len_norm_type_width * '-',
                    len_norm_width * '-',
                ) + '\n'
                comp_error_string = header + comp_error_string
                error_string += comp_error_string
    
        # if error string then raise error with that string
        if error_string:
            header_line1 = 'Assert Check Partials failed for the following Components'
            header_line2 = 'with absolute tolerance = {} and relative tolerance = {}'.format(atol, rtol)
            header_width = max(len(header_line1), len(header_line2))
            header = '\n' + header_width * '=' + '\n'
            header += header_line1 + '\n'
            header += header_line2 + '\n'
            header += header_width * '=' + '\n'
            error_string = header + error_string
>           raise ValueError(error_string)
E           ValueError: 
E           ==============================================================
E           Assert Check Partials failed for the following Components
E           with absolute tolerance = 1e-06 and relative tolerance = 1e-06
E           ==============================================================
E           -------------------------
E           Component: rk_integrator
E           -------------------------
E           < output > wrt < variable > | abs/rel | norm   | norm value            
E           --------------------------- | ------- | ------ | ----------------------
E           x_final wrt b               | rel     | fwd-fd | 3.4803830924019174e-06
E           x_final wrt b               | rel     | rev-fd | 3.4803830922299024e-06

/home/shuv_im/.spack/rev.23.05/install/linux-rocky8-zen2/gcc-10.4.0/py-openmdao-3.9.1-dlr.6-w57zdo/lib/python3.9/site-packages/openmdao/utils/assert_utils.py:225: ValueError
----------------------------- Captured stdout call -----------------------------


Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting fwd-mode jacvec product


Resetting error estimator.


Starting step 1 of fwd-mode jacvec product.
Time = 1.0, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 1.
Starting stage 2 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 1.
Starting stage 3 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 1.
Starting stage 4 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 1.

Finished step 1 of fwd-mode jacvec product.


Starting step 2 of fwd-mode jacvec product.
Time = 1.001, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 2.
Starting stage 2 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 2.
Starting stage 3 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 2.
Starting stage 4 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 2.

Finished step 2 of fwd-mode jacvec product.


Starting step 3 of fwd-mode jacvec product.
Time = 1.0025588641016578, dTime = 0.0015588641016579831.

Starting stage 1 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 3.
Starting stage 2 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 3.
Starting stage 3 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 3.
Starting stage 4 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 3.

Finished step 3 of fwd-mode jacvec product.


Starting step 4 of fwd-mode jacvec product.
Time = 1.0088640455029265, dTime = 0.006305181401268689.

Starting stage 1 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 4.
Starting stage 2 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 4.
Starting stage 3 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 4.
Starting stage 4 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 4.

Finished step 4 of fwd-mode jacvec product.



Finished fwd-mode jacvec product




Starting fwd-mode jacvec product


Resetting error estimator.


Starting step 1 of fwd-mode jacvec product.
Time = 1.0, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 1.
Starting stage 2 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 1.
Starting stage 3 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 1.
Starting stage 4 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 1.

Finished step 1 of fwd-mode jacvec product.


Starting step 2 of fwd-mode jacvec product.
Time = 1.001, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 2.
Starting stage 2 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 2.
Starting stage 3 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 2.
Starting stage 4 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 2.

Finished step 2 of fwd-mode jacvec product.


Starting step 3 of fwd-mode jacvec product.
Time = 1.0025588641016578, dTime = 0.0015588641016579831.

Starting stage 1 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 3.
Starting stage 2 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 3.
Starting stage 3 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 3.
Starting stage 4 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 3.

Finished step 3 of fwd-mode jacvec product.


Starting step 4 of fwd-mode jacvec product.
Time = 1.0088640455029265, dTime = 0.006305181401268689.

Starting stage 1 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 4.
Starting stage 2 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 4.
Starting stage 3 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 4.
Starting stage 4 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 4.

Finished step 4 of fwd-mode jacvec product.



Finished fwd-mode jacvec product




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting rev-mode jacvec product



Starting step 4 of rev-mode jacvec product.
Time = 1.0088640455029265, dTime = 0.001135954497073488.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 3 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Finished stage 3 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 4 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.
Finished stage 4 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 4 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 4 of the rev iteration of reve-mode jvp in
step 4.
Starting stage 3 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 3 of the rev iteration of reve-mode jvp in
step 4.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 4.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 4.

Finishing step 4 of rev-mode jacvec product.


Starting step 3 of rev-mode jacvec product.
Time = 1.0025588641016578, dTime = 0.006305181401268689.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 3 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Finished stage 3 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 4 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.
Finished stage 4 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 4 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 4 of the rev iteration of reve-mode jvp in
step 3.
Starting stage 3 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 3 of the rev iteration of reve-mode jvp in
step 3.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 3.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 3.

Finishing step 3 of rev-mode jacvec product.


Starting step 2 of rev-mode jacvec product.
Time = 1.001, dTime = 0.0015588641016579831.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 3 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Finished stage 3 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 4 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.
Finished stage 4 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 4 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 4 of the rev iteration of reve-mode jvp in
step 2.
Starting stage 3 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 3 of the rev iteration of reve-mode jvp in
step 2.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 2.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 2.

Finishing step 2 of rev-mode jacvec product.


Starting step 1 of rev-mode jacvec product.
Time = 1.0, dTime = 0.001.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 3 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Finished stage 3 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 4 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.
Finished stage 4 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 4 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 4 of the rev iteration of reve-mode jvp in
step 1.
Starting stage 3 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 3 of the rev iteration of reve-mode jvp in
step 1.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 1.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 1.

Finishing step 1 of rev-mode jacvec product.



Finished rev-mode jacvec product




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.

Finishing step 4 of compute.



Finishing compute


-----------------------------------------------
Component: RungeKuttaIntegrator 'rk_integrator'
-----------------------------------------------
  rk_integrator: 'x_final' wrt 'b'
     Forward Magnitude: 1.008467e-02
     Reverse Magnitude: 1.008467e-02
          Fd Magnitude: 1.008470e-02 (fd:forward)
    Absolute Error (Jfor - Jfd) : 3.509864e-08
    Absolute Error (Jrev - Jfd) : 3.509864e-08
    Absolute Error (Jfor - Jrev): 1.734723e-18

    Relative Error (Jfor - Jfd) / Jfd : 3.480383e-06 *
    Relative Error (Jrev - Jfd) / Jfd : 3.480383e-06 *
    Relative Error (Jfor - Jrev) / Jfd: 1.720153e-16

    Raw Forward Derivative (Jfor)
[[0.01008467]]

    Raw Reverse Derivative (Jrev)
[[0.01008467]]

    Raw FD Derivative (Jfd)
[[0.0100847]]

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  rk_integrator: 'x_final' wrt 'x_initial'
     Forward Magnitude: 1.010050e+00
     Reverse Magnitude: 1.010050e+00
          Fd Magnitude: 1.010050e+00 (fd:forward)
    Absolute Error (Jfor - Jfd) : 1.823652e-11
    Absolute Error (Jrev - Jfd) : 1.823675e-11
    Absolute Error (Jfor - Jrev): 2.220446e-16

    Relative Error (Jfor - Jfd) / Jfd : 1.805507e-11
    Relative Error (Jrev - Jfd) / Jfd : 1.805529e-11
    Relative Error (Jfor - Jrev) / Jfd: 2.198352e-16

    Raw Forward Derivative (Jfor)
[[1.01005017]]

    Raw Reverse Derivative (Jrev)
[[1.01005017]]

    Raw FD Derivative (Jfd)
[[1.01005017]]

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
_ test_time_integration_with_parameter_partials[PID-SimpleErrorEstimator-AllCheckpointer-butcher_tableau4-1.0-TestComp1-0.0] _

test_class = <class 'tests.test_components.TestComp1'>, initial_time = 0.0
parameter = 1.0
butcher_tableau = <rkopenmdao.butcher_tableau.EmbeddedButcherTableau object at 0x15551f7d7d30>
checkpointing_implementation = <class 'rkopenmdao.checkpoint_interface.all_checkpointer.AllCheckpointer'>
test_estimator = <class 'rkopenmdao.error_estimator.SimpleErrorEstimator'>
test_controller = <function PID at 0x1555201d5550>

    @pytest.mark.rk
    @pytest.mark.rk_openmdao
    @pytest.mark.parametrize(
        "test_class, initial_time",
        (
            [TestComp1, 0.0],
            [TestComp1, 1.0],
        ),
    )
    @pytest.mark.parametrize("parameter", [1.0])
    @pytest.mark.parametrize(
        "butcher_tableau",
        [
            heun_euler,
            two_stage_dirk,
            three_stage_esdirk,
            four_stage_esdirk,
            five_stage_esdirk
        ]
    )
    @pytest.mark.parametrize(
        "checkpointing_implementation",
        [
            NoCheckpointer,
            AllCheckpointer,
        ],
    )
    @pytest.mark.parametrize(
        "test_estimator",
        [
            SimpleErrorEstimator,
            ImprovedErrorEstimator
        ]
    )
    @pytest.mark.parametrize(
        "test_controller",
        [
            Integral,
            H0_110,
            PID
        ]
    )
    def test_time_integration_with_parameter_partials(
        test_class, initial_time, parameter, butcher_tableau, checkpointing_implementation, test_estimator, test_controller
    ):
        """Tests the partials of the time integration of the different components."""
        termination_criterion = TerminationCriterion('end_time', initial_time + 0.01)
        integration_control = IntegrationControl(initial_time, termination_criterion, 0.001)
        time_integration_prob = om.Problem()
        time_integration_prob.model.add_subsystem(
            "test_comp", test_class(integration_control=integration_control)
        )
    
        time_integration_prob.model.nonlinear_solver = om.NewtonSolver(
            solve_subsystems=True
        )
        time_integration_prob.model.linear_solver = om.ScipyKrylov()
    
        runge_kutta_prob = om.Problem()
        runge_kutta_prob.model.add_subsystem(
            "rk_integrator",
            RungeKuttaIntegrator(
                time_stage_problem=time_integration_prob,
                butcher_tableau=butcher_tableau,
                integration_control=integration_control,
                time_integration_quantities=["x"],
                time_independent_input_quantities=["b"],
                checkpointing_type=checkpointing_implementation,
                error_controller=test_controller,
                error_estimator_type=test_estimator,
                adaptive_time_stepping=True,
            ),
            promotes=["*"],
        )
    
        runge_kutta_prob.setup()
        runge_kutta_prob["b"] = parameter
        runge_kutta_prob.run_model()
        if checkpointing_implementation == NoCheckpointer:
            with pytest.raises(NotImplementedError):
                runge_kutta_prob.check_partials(excludes=["Jfd","fd","Jfor-Jfd","Jrev-Jfd"])
        else:
            data = runge_kutta_prob.check_partials()
>           assert_check_partials(data)

test_component_test_adaptive.py:517: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = {'rk_integrator': {('x_final', 'b'): {'J_fd': array([[0.01008709]]), 'J_fwd': array([[0.01008735]]), 'J_rev': array([[...rorTuple(forward=2.3498314405401288e-11, reverse=2.3498092360796363e-11, forward_reverse=2.220446049250313e-16), ...}}}
atol = 1e-06, rtol = 1e-06

    def assert_check_partials(data, atol=1e-6, rtol=1e-6):
        """
        Raise assertion if any entry from the return from check_partials is above a tolerance.
    
        Parameters
        ----------
        data : dict of dicts of dicts
                First key:
                    is the component name;
                Second key:
                    is the (output, input) tuple of strings;
                Third key:
                    is one of ['rel error', 'abs error', 'magnitude', 'J_fd', 'J_fwd', 'J_rev'];
    
                For 'rel error', 'abs error', 'magnitude' the value is: A tuple containing norms for
                    forward - fd, adjoint - fd, forward - adjoint.
                For 'J_fd', 'J_fwd', 'J_rev' the value is: A numpy array representing the computed
                    Jacobian for the three different methods of computation.
        atol : float
            absolute error. Default is 1e-6.
        rtol : float
            relative error. Default is 1e-6.
        """
        error_string = ''
        absrel_header = 'abs/rel'
        wrt_header = '< output > wrt < variable >'
        norm_value_header = 'norm value'
        len_absrel_width = len(absrel_header)
        norm_types = ['fwd-fd', 'rev-fd', 'fd-rev']
        len_norm_type_width = max(len(s) for s in norm_types)
    
        for comp in data:
            len_wrt_width = len(wrt_header)
            len_norm_width = len(norm_value_header)
            bad_derivs = []
    
            # Find all derivatives whose errors exceed tolerance.
            # Also, size the output to precompute column extents.
            for (var, wrt) in data[comp]:
                pair_data = data[comp][var, wrt]
                for error_type, tolerance in [('abs error', atol), ('rel error', rtol), ]:
                    actual = pair_data[error_type]
                    for error_val, mode in zip(actual, norm_types):
                        in_error = False
    
                        if error_val is None:
                            # Reverse derivatives only computed on matrix free comps.
                            continue
    
                        if not np.isnan(error_val):
                            if not np.allclose(error_val, 0.0, atol=tolerance):
    
                                if error_type == 'rel error' and mode == 'fwd-fd' and \
                                   np.allclose(pair_data['J_fwd'], 0.0, atol=atol) and \
                                   np.allclose(pair_data['J_fd'], 0.0, atol=atol):
                                    # Special case: both fd and fwd are really tiny, so we want to
                                    # ignore the rather large relative errors.
                                    in_error = False
                                else:
                                    # This is a bona-fide error.
                                    in_error = True
    
                        elif error_type == 'abs error' and mode == 'fwd-fd':
                            # Either analytic or approximated derivatives contain a NaN.
                            in_error = True
    
                        if in_error:
                            wrt_string = '{0} wrt {1}'.format(var, wrt)
                            norm_string = '{}'.format(error_val)
                            bad_derivs.append((wrt_string, norm_string, error_type, mode))
                            len_wrt_width = max(len_wrt_width, len(wrt_string))
                            len_norm_width = max(len_norm_width, len(norm_string))
    
            if bad_derivs:
                comp_error_string = ''
                for wrt_string, norm_string, error_type, mode in bad_derivs:
                    err_msg = '{0} | {1} | {2} | {3}'.format(
                        pad_name(wrt_string, len_wrt_width),
                        pad_name(error_type.split()[0], len_absrel_width),
                        pad_name(mode, len_norm_type_width),
                        pad_name(norm_string, len_norm_width)) + '\n'
                    comp_error_string += err_msg
    
                name_header = 'Component: {}\n'.format(comp)
                len_name_header = len(name_header)
                header = len_name_header * '-' + '\n'
                header += name_header
                header += len_name_header * '-' + '\n'
                header += '{0} | {1} | {2} | {3}'.format(
                    pad_name(wrt_header, len_wrt_width),
                    pad_name(absrel_header, len_absrel_width),
                    pad_name('norm', len_norm_type_width),
                    pad_name(norm_value_header, len_norm_width),
                ) + '\n'
                header += '{0} | {1} | {2} | {3}'.format(
                    len_wrt_width * '-',
                    len_absrel_width * '-',
                    len_norm_type_width * '-',
                    len_norm_width * '-',
                ) + '\n'
                comp_error_string = header + comp_error_string
                error_string += comp_error_string
    
        # if error string then raise error with that string
        if error_string:
            header_line1 = 'Assert Check Partials failed for the following Components'
            header_line2 = 'with absolute tolerance = {} and relative tolerance = {}'.format(atol, rtol)
            header_width = max(len(header_line1), len(header_line2))
            header = '\n' + header_width * '=' + '\n'
            header += header_line1 + '\n'
            header += header_line2 + '\n'
            header += header_width * '=' + '\n'
            error_string = header + error_string
>           raise ValueError(error_string)
E           ValueError: 
E           ==============================================================
E           Assert Check Partials failed for the following Components
E           with absolute tolerance = 1e-06 and relative tolerance = 1e-06
E           ==============================================================
E           -------------------------
E           Component: rk_integrator
E           -------------------------
E           < output > wrt < variable > | abs/rel | norm   | norm value            
E           --------------------------- | ------- | ------ | ----------------------
E           x_final wrt b               | rel     | fwd-fd | 2.5528062061402712e-05
E           x_final wrt b               | rel     | rev-fd | 2.5528062061402712e-05

/home/shuv_im/.spack/rev.23.05/install/linux-rocky8-zen2/gcc-10.4.0/py-openmdao-3.9.1-dlr.6-w57zdo/lib/python3.9/site-packages/openmdao/utils/assert_utils.py:225: ValueError
----------------------------- Captured stdout call -----------------------------


Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.
Starting stage 5 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.
Starting stage 5 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.
Starting stage 5 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.
Starting stage 5 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.
Starting stage 5 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.
Starting stage 5 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.
Starting stage 5 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.
Starting stage 5 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting fwd-mode jacvec product


Resetting error estimator.


Starting step 1 of fwd-mode jacvec product.
Time = 0.0, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 1.
Starting stage 2 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 1.
Starting stage 3 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 1.
Starting stage 4 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 1.
Starting stage 5 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 5 of fwd-mode jacvec product in step 1.

Finished step 1 of fwd-mode jacvec product.


Starting step 2 of fwd-mode jacvec product.
Time = 0.001, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 2.
Starting stage 2 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 2.
Starting stage 3 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 2.
Starting stage 4 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 2.
Starting stage 5 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 5 of fwd-mode jacvec product in step 2.

Finished step 2 of fwd-mode jacvec product.


Starting step 3 of fwd-mode jacvec product.
Time = 0.0022518533519570554, dTime = 0.0012518533519570556.

Starting stage 1 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 3.
Starting stage 2 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 3.
Starting stage 3 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 3.
Starting stage 4 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 3.
Starting stage 5 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 5 of fwd-mode jacvec product in step 3.

Finished step 3 of fwd-mode jacvec product.


Starting step 4 of fwd-mode jacvec product.
Time = 0.004928122293911817, dTime = 0.002676268941954761.

Starting stage 1 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 4.
Starting stage 2 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 4.
Starting stage 3 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 4.
Starting stage 4 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 4.
Starting stage 5 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 5 of fwd-mode jacvec product in step 4.

Finished step 4 of fwd-mode jacvec product.



Finished fwd-mode jacvec product




Starting fwd-mode jacvec product


Resetting error estimator.


Starting step 1 of fwd-mode jacvec product.
Time = 0.0, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 1.
Starting stage 2 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 1.
Starting stage 3 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 1.
Starting stage 4 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 1.
Starting stage 5 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 5 of fwd-mode jacvec product in step 1.

Finished step 1 of fwd-mode jacvec product.


Starting step 2 of fwd-mode jacvec product.
Time = 0.001, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 2.
Starting stage 2 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 2.
Starting stage 3 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 2.
Starting stage 4 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 2.
Starting stage 5 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 5 of fwd-mode jacvec product in step 2.

Finished step 2 of fwd-mode jacvec product.


Starting step 3 of fwd-mode jacvec product.
Time = 0.0022518533519570554, dTime = 0.0012518533519570556.

Starting stage 1 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 3.
Starting stage 2 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 3.
Starting stage 3 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 3.
Starting stage 4 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 3.
Starting stage 5 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 5 of fwd-mode jacvec product in step 3.

Finished step 3 of fwd-mode jacvec product.


Starting step 4 of fwd-mode jacvec product.
Time = 0.004928122293911817, dTime = 0.002676268941954761.

Starting stage 1 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 4.
Starting stage 2 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 4.
Starting stage 3 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 4.
Starting stage 4 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 4.
Starting stage 5 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 5 of fwd-mode jacvec product in step 4.

Finished step 4 of fwd-mode jacvec product.



Finished fwd-mode jacvec product




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.
Starting stage 5 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.
Starting stage 5 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.
Starting stage 5 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.
Starting stage 5 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting rev-mode jacvec product



Starting step 4 of rev-mode jacvec product.
Time = 0.004928122293911817, dTime = 0.005071877706088183.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 3 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Finished stage 3 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 4 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.
Finished stage 4 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 5 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 5 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 4.
Finished stage 5 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 5 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 5 of the rev iteration of reve-mode jvp in
step 4.
Starting stage 4 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 4 of the rev iteration of reve-mode jvp in
step 4.
Starting stage 3 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 3 of the rev iteration of reve-mode jvp in
step 4.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 4.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 4.

Finishing step 4 of rev-mode jacvec product.


Starting step 3 of rev-mode jacvec product.
Time = 0.0022518533519570554, dTime = 0.002676268941954761.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 3 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Finished stage 3 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 4 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.
Finished stage 4 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 5 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 5 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 3.
Finished stage 5 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 5 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 5 of the rev iteration of reve-mode jvp in
step 3.
Starting stage 4 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 4 of the rev iteration of reve-mode jvp in
step 3.
Starting stage 3 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 3 of the rev iteration of reve-mode jvp in
step 3.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 3.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 3.

Finishing step 3 of rev-mode jacvec product.


Starting step 2 of rev-mode jacvec product.
Time = 0.001, dTime = 0.0012518533519570556.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 3 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Finished stage 3 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 4 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.
Finished stage 4 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 5 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 5 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 2.
Finished stage 5 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 5 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 5 of the rev iteration of reve-mode jvp in
step 2.
Starting stage 4 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 4 of the rev iteration of reve-mode jvp in
step 2.
Starting stage 3 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 3 of the rev iteration of reve-mode jvp in
step 2.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 2.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 2.

Finishing step 2 of rev-mode jacvec product.


Starting step 1 of rev-mode jacvec product.
Time = 0.0, dTime = 0.001.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 3 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Finished stage 3 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 4 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.
Finished stage 4 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 5 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 5 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 1.
Finished stage 5 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 5 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 5 of the rev iteration of reve-mode jvp in
step 1.
Starting stage 4 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 4 of the rev iteration of reve-mode jvp in
step 1.
Starting stage 3 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 3 of the rev iteration of reve-mode jvp in
step 1.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 1.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 1.

Finishing step 1 of rev-mode jacvec product.



Finished rev-mode jacvec product




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.
Starting stage 5 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.
Starting stage 5 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.
Starting stage 5 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.
Starting stage 5 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.
Starting stage 5 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.
Starting stage 5 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.
Starting stage 5 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.
Starting stage 5 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.
Starting stage 5 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.
Starting stage 5 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.
Starting stage 5 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.
Starting stage 5 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 4.

Finishing step 4 of compute.



Finishing compute


-----------------------------------------------
Component: RungeKuttaIntegrator 'rk_integrator'
-----------------------------------------------
  rk_integrator: 'x_final' wrt 'b'
     Forward Magnitude: 1.008735e-02
     Reverse Magnitude: 1.008735e-02
          Fd Magnitude: 1.008709e-02 (fd:forward)
    Absolute Error (Jfor - Jfd) : 2.575038e-07
    Absolute Error (Jrev - Jfd) : 2.575038e-07
    Absolute Error (Jfor - Jrev): 0.000000e+00

    Relative Error (Jfor - Jfd) / Jfd : 2.552806e-05 *
    Relative Error (Jrev - Jfd) / Jfd : 2.552806e-05 *
    Relative Error (Jfor - Jrev) / Jfd: 0.000000e+00

    Raw Forward Derivative (Jfor)
[[0.01008735]]

    Raw Reverse Derivative (Jrev)
[[0.01008735]]

    Raw FD Derivative (Jfd)
[[0.01008709]]

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  rk_integrator: 'x_final' wrt 'x_initial'
     Forward Magnitude: 1.010050e+00
     Reverse Magnitude: 1.010050e+00
          Fd Magnitude: 1.010050e+00 (fd:forward)
    Absolute Error (Jfor - Jfd) : 2.349831e-11
    Absolute Error (Jrev - Jfd) : 2.349809e-11
    Absolute Error (Jfor - Jrev): 2.220446e-16

    Relative Error (Jfor - Jfd) / Jfd : 2.326450e-11
    Relative Error (Jrev - Jfd) / Jfd : 2.326428e-11
    Relative Error (Jfor - Jrev) / Jfd: 2.198352e-16

    Raw Forward Derivative (Jfor)
[[1.01005017]]

    Raw Reverse Derivative (Jrev)
[[1.01005017]]

    Raw FD Derivative (Jfd)
[[1.01005017]]

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
_ test_time_integration_with_parameter_partials[PID-SimpleErrorEstimator-AllCheckpointer-butcher_tableau4-1.0-TestComp1-1.0] _

test_class = <class 'tests.test_components.TestComp1'>, initial_time = 1.0
parameter = 1.0
butcher_tableau = <rkopenmdao.butcher_tableau.EmbeddedButcherTableau object at 0x15551f7d7d30>
checkpointing_implementation = <class 'rkopenmdao.checkpoint_interface.all_checkpointer.AllCheckpointer'>
test_estimator = <class 'rkopenmdao.error_estimator.SimpleErrorEstimator'>
test_controller = <function PID at 0x1555201d5550>

    @pytest.mark.rk
    @pytest.mark.rk_openmdao
    @pytest.mark.parametrize(
        "test_class, initial_time",
        (
            [TestComp1, 0.0],
            [TestComp1, 1.0],
        ),
    )
    @pytest.mark.parametrize("parameter", [1.0])
    @pytest.mark.parametrize(
        "butcher_tableau",
        [
            heun_euler,
            two_stage_dirk,
            three_stage_esdirk,
            four_stage_esdirk,
            five_stage_esdirk
        ]
    )
    @pytest.mark.parametrize(
        "checkpointing_implementation",
        [
            NoCheckpointer,
            AllCheckpointer,
        ],
    )
    @pytest.mark.parametrize(
        "test_estimator",
        [
            SimpleErrorEstimator,
            ImprovedErrorEstimator
        ]
    )
    @pytest.mark.parametrize(
        "test_controller",
        [
            Integral,
            H0_110,
            PID
        ]
    )
    def test_time_integration_with_parameter_partials(
        test_class, initial_time, parameter, butcher_tableau, checkpointing_implementation, test_estimator, test_controller
    ):
        """Tests the partials of the time integration of the different components."""
        termination_criterion = TerminationCriterion('end_time', initial_time + 0.01)
        integration_control = IntegrationControl(initial_time, termination_criterion, 0.001)
        time_integration_prob = om.Problem()
        time_integration_prob.model.add_subsystem(
            "test_comp", test_class(integration_control=integration_control)
        )
    
        time_integration_prob.model.nonlinear_solver = om.NewtonSolver(
            solve_subsystems=True
        )
        time_integration_prob.model.linear_solver = om.ScipyKrylov()
    
        runge_kutta_prob = om.Problem()
        runge_kutta_prob.model.add_subsystem(
            "rk_integrator",
            RungeKuttaIntegrator(
                time_stage_problem=time_integration_prob,
                butcher_tableau=butcher_tableau,
                integration_control=integration_control,
                time_integration_quantities=["x"],
                time_independent_input_quantities=["b"],
                checkpointing_type=checkpointing_implementation,
                error_controller=test_controller,
                error_estimator_type=test_estimator,
                adaptive_time_stepping=True,
            ),
            promotes=["*"],
        )
    
        runge_kutta_prob.setup()
        runge_kutta_prob["b"] = parameter
        runge_kutta_prob.run_model()
        if checkpointing_implementation == NoCheckpointer:
            with pytest.raises(NotImplementedError):
                runge_kutta_prob.check_partials(excludes=["Jfd","fd","Jfor-Jfd","Jrev-Jfd"])
        else:
            data = runge_kutta_prob.check_partials()
>           assert_check_partials(data)

test_component_test_adaptive.py:517: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = {'rk_integrator': {('x_final', 'b'): {'J_fd': array([[0.01008709]]), 'J_fwd': array([[0.01008735]]), 'J_rev': array([[...rorTuple(forward=2.3498536450006213e-11, reverse=2.3498314405401288e-11, forward_reverse=2.220446049250313e-16), ...}}}
atol = 1e-06, rtol = 1e-06

    def assert_check_partials(data, atol=1e-6, rtol=1e-6):
        """
        Raise assertion if any entry from the return from check_partials is above a tolerance.
    
        Parameters
        ----------
        data : dict of dicts of dicts
                First key:
                    is the component name;
                Second key:
                    is the (output, input) tuple of strings;
                Third key:
                    is one of ['rel error', 'abs error', 'magnitude', 'J_fd', 'J_fwd', 'J_rev'];
    
                For 'rel error', 'abs error', 'magnitude' the value is: A tuple containing norms for
                    forward - fd, adjoint - fd, forward - adjoint.
                For 'J_fd', 'J_fwd', 'J_rev' the value is: A numpy array representing the computed
                    Jacobian for the three different methods of computation.
        atol : float
            absolute error. Default is 1e-6.
        rtol : float
            relative error. Default is 1e-6.
        """
        error_string = ''
        absrel_header = 'abs/rel'
        wrt_header = '< output > wrt < variable >'
        norm_value_header = 'norm value'
        len_absrel_width = len(absrel_header)
        norm_types = ['fwd-fd', 'rev-fd', 'fd-rev']
        len_norm_type_width = max(len(s) for s in norm_types)
    
        for comp in data:
            len_wrt_width = len(wrt_header)
            len_norm_width = len(norm_value_header)
            bad_derivs = []
    
            # Find all derivatives whose errors exceed tolerance.
            # Also, size the output to precompute column extents.
            for (var, wrt) in data[comp]:
                pair_data = data[comp][var, wrt]
                for error_type, tolerance in [('abs error', atol), ('rel error', rtol), ]:
                    actual = pair_data[error_type]
                    for error_val, mode in zip(actual, norm_types):
                        in_error = False
    
                        if error_val is None:
                            # Reverse derivatives only computed on matrix free comps.
                            continue
    
                        if not np.isnan(error_val):
                            if not np.allclose(error_val, 0.0, atol=tolerance):
    
                                if error_type == 'rel error' and mode == 'fwd-fd' and \
                                   np.allclose(pair_data['J_fwd'], 0.0, atol=atol) and \
                                   np.allclose(pair_data['J_fd'], 0.0, atol=atol):
                                    # Special case: both fd and fwd are really tiny, so we want to
                                    # ignore the rather large relative errors.
                                    in_error = False
                                else:
                                    # This is a bona-fide error.
                                    in_error = True
    
                        elif error_type == 'abs error' and mode == 'fwd-fd':
                            # Either analytic or approximated derivatives contain a NaN.
                            in_error = True
    
                        if in_error:
                            wrt_string = '{0} wrt {1}'.format(var, wrt)
                            norm_string = '{}'.format(error_val)
                            bad_derivs.append((wrt_string, norm_string, error_type, mode))
                            len_wrt_width = max(len_wrt_width, len(wrt_string))
                            len_norm_width = max(len_norm_width, len(norm_string))
    
            if bad_derivs:
                comp_error_string = ''
                for wrt_string, norm_string, error_type, mode in bad_derivs:
                    err_msg = '{0} | {1} | {2} | {3}'.format(
                        pad_name(wrt_string, len_wrt_width),
                        pad_name(error_type.split()[0], len_absrel_width),
                        pad_name(mode, len_norm_type_width),
                        pad_name(norm_string, len_norm_width)) + '\n'
                    comp_error_string += err_msg
    
                name_header = 'Component: {}\n'.format(comp)
                len_name_header = len(name_header)
                header = len_name_header * '-' + '\n'
                header += name_header
                header += len_name_header * '-' + '\n'
                header += '{0} | {1} | {2} | {3}'.format(
                    pad_name(wrt_header, len_wrt_width),
                    pad_name(absrel_header, len_absrel_width),
                    pad_name('norm', len_norm_type_width),
                    pad_name(norm_value_header, len_norm_width),
                ) + '\n'
                header += '{0} | {1} | {2} | {3}'.format(
                    len_wrt_width * '-',
                    len_absrel_width * '-',
                    len_norm_type_width * '-',
                    len_norm_width * '-',
                ) + '\n'
                comp_error_string = header + comp_error_string
                error_string += comp_error_string
    
        # if error string then raise error with that string
        if error_string:
            header_line1 = 'Assert Check Partials failed for the following Components'
            header_line2 = 'with absolute tolerance = {} and relative tolerance = {}'.format(atol, rtol)
            header_width = max(len(header_line1), len(header_line2))
            header = '\n' + header_width * '=' + '\n'
            header += header_line1 + '\n'
            header += header_line2 + '\n'
            header += header_width * '=' + '\n'
            error_string = header + error_string
>           raise ValueError(error_string)
E           ValueError: 
E           ==============================================================
E           Assert Check Partials failed for the following Components
E           with absolute tolerance = 1e-06 and relative tolerance = 1e-06
E           ==============================================================
E           -------------------------
E           Component: rk_integrator
E           -------------------------
E           < output > wrt < variable > | abs/rel | norm   | norm value            
E           --------------------------- | ------- | ------ | ----------------------
E           x_final wrt b               | rel     | fwd-fd | 2.5528062073440938e-05
E           x_final wrt b               | rel     | rev-fd | 2.552806207275304e-05

/home/shuv_im/.spack/rev.23.05/install/linux-rocky8-zen2/gcc-10.4.0/py-openmdao-3.9.1-dlr.6-w57zdo/lib/python3.9/site-packages/openmdao/utils/assert_utils.py:225: ValueError
----------------------------- Captured stdout call -----------------------------


Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.
Starting stage 5 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.
Starting stage 5 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.
Starting stage 5 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.
Starting stage 5 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.
Starting stage 5 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.
Starting stage 5 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.
Starting stage 5 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.
Starting stage 5 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting fwd-mode jacvec product


Resetting error estimator.


Starting step 1 of fwd-mode jacvec product.
Time = 1.0, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 1.
Starting stage 2 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 1.
Starting stage 3 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 1.
Starting stage 4 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 1.
Starting stage 5 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 5 of fwd-mode jacvec product in step 1.

Finished step 1 of fwd-mode jacvec product.


Starting step 2 of fwd-mode jacvec product.
Time = 1.001, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 2.
Starting stage 2 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 2.
Starting stage 3 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 2.
Starting stage 4 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 2.
Starting stage 5 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 5 of fwd-mode jacvec product in step 2.

Finished step 2 of fwd-mode jacvec product.


Starting step 3 of fwd-mode jacvec product.
Time = 1.0022518533519569, dTime = 0.0012518533519570556.

Starting stage 1 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 3.
Starting stage 2 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 3.
Starting stage 3 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 3.
Starting stage 4 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 3.
Starting stage 5 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 5 of fwd-mode jacvec product in step 3.

Finished step 3 of fwd-mode jacvec product.


Starting step 4 of fwd-mode jacvec product.
Time = 1.0049281222939117, dTime = 0.002676268941954761.

Starting stage 1 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 4.
Starting stage 2 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 4.
Starting stage 3 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 4.
Starting stage 4 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 4.
Starting stage 5 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 5 of fwd-mode jacvec product in step 4.

Finished step 4 of fwd-mode jacvec product.



Finished fwd-mode jacvec product




Starting fwd-mode jacvec product


Resetting error estimator.


Starting step 1 of fwd-mode jacvec product.
Time = 1.0, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 1.
Starting stage 2 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 1.
Starting stage 3 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 1.
Starting stage 4 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 1.
Starting stage 5 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 5 of fwd-mode jacvec product in step 1.

Finished step 1 of fwd-mode jacvec product.


Starting step 2 of fwd-mode jacvec product.
Time = 1.001, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 2.
Starting stage 2 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 2.
Starting stage 3 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 2.
Starting stage 4 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 2.
Starting stage 5 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 5 of fwd-mode jacvec product in step 2.

Finished step 2 of fwd-mode jacvec product.


Starting step 3 of fwd-mode jacvec product.
Time = 1.0022518533519569, dTime = 0.0012518533519570556.

Starting stage 1 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 3.
Starting stage 2 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 3.
Starting stage 3 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 3.
Starting stage 4 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 3.
Starting stage 5 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 5 of fwd-mode jacvec product in step 3.

Finished step 3 of fwd-mode jacvec product.


Starting step 4 of fwd-mode jacvec product.
Time = 1.0049281222939117, dTime = 0.002676268941954761.

Starting stage 1 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 4.
Starting stage 2 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 4.
Starting stage 3 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 4.
Starting stage 4 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 4.
Starting stage 5 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 5 of fwd-mode jacvec product in step 4.

Finished step 4 of fwd-mode jacvec product.



Finished fwd-mode jacvec product




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.
Starting stage 5 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.
Starting stage 5 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.
Starting stage 5 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.
Starting stage 5 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting rev-mode jacvec product



Starting step 4 of rev-mode jacvec product.
Time = 1.0049281222939117, dTime = 0.005071877706088301.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 3 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Finished stage 3 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 4 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.
Finished stage 4 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 5 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 5 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 4.
Finished stage 5 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 5 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 5 of the rev iteration of reve-mode jvp in
step 4.
Starting stage 4 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 4 of the rev iteration of reve-mode jvp in
step 4.
Starting stage 3 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 3 of the rev iteration of reve-mode jvp in
step 4.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 4.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 4.

Finishing step 4 of rev-mode jacvec product.


Starting step 3 of rev-mode jacvec product.
Time = 1.0022518533519569, dTime = 0.002676268941954761.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 3 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Finished stage 3 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 4 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.
Finished stage 4 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 5 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 5 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 3.
Finished stage 5 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 5 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 5 of the rev iteration of reve-mode jvp in
step 3.
Starting stage 4 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 4 of the rev iteration of reve-mode jvp in
step 3.
Starting stage 3 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 3 of the rev iteration of reve-mode jvp in
step 3.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 3.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 3.

Finishing step 3 of rev-mode jacvec product.


Starting step 2 of rev-mode jacvec product.
Time = 1.001, dTime = 0.0012518533519570556.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 3 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Finished stage 3 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 4 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.
Finished stage 4 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 5 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 5 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 2.
Finished stage 5 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 5 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 5 of the rev iteration of reve-mode jvp in
step 2.
Starting stage 4 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 4 of the rev iteration of reve-mode jvp in
step 2.
Starting stage 3 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 3 of the rev iteration of reve-mode jvp in
step 2.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 2.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 2.

Finishing step 2 of rev-mode jacvec product.


Starting step 1 of rev-mode jacvec product.
Time = 1.0, dTime = 0.001.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 3 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Finished stage 3 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 4 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.
Finished stage 4 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 5 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 5 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 1.
Finished stage 5 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 5 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 5 of the rev iteration of reve-mode jvp in
step 1.
Starting stage 4 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 4 of the rev iteration of reve-mode jvp in
step 1.
Starting stage 3 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 3 of the rev iteration of reve-mode jvp in
step 1.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 1.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 1.

Finishing step 1 of rev-mode jacvec product.



Finished rev-mode jacvec product




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.
Starting stage 5 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.
Starting stage 5 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.
Starting stage 5 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.
Starting stage 5 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.
Starting stage 5 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.
Starting stage 5 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.
Starting stage 5 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.
Starting stage 5 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.
Starting stage 5 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.
Starting stage 5 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.
Starting stage 5 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.
Starting stage 5 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 4.

Finishing step 4 of compute.



Finishing compute


-----------------------------------------------
Component: RungeKuttaIntegrator 'rk_integrator'
-----------------------------------------------
  rk_integrator: 'x_final' wrt 'b'
     Forward Magnitude: 1.008735e-02
     Reverse Magnitude: 1.008735e-02
          Fd Magnitude: 1.008709e-02 (fd:forward)
    Absolute Error (Jfor - Jfd) : 2.575038e-07
    Absolute Error (Jrev - Jfd) : 2.575038e-07
    Absolute Error (Jfor - Jrev): 6.938894e-18

    Relative Error (Jfor - Jfd) / Jfd : 2.552806e-05 *
    Relative Error (Jrev - Jfd) / Jfd : 2.552806e-05 *
    Relative Error (Jfor - Jrev) / Jfd: 6.878986e-16

    Raw Forward Derivative (Jfor)
[[0.01008735]]

    Raw Reverse Derivative (Jrev)
[[0.01008735]]

    Raw FD Derivative (Jfd)
[[0.01008709]]

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  rk_integrator: 'x_final' wrt 'x_initial'
     Forward Magnitude: 1.010050e+00
     Reverse Magnitude: 1.010050e+00
          Fd Magnitude: 1.010050e+00 (fd:forward)
    Absolute Error (Jfor - Jfd) : 2.349854e-11
    Absolute Error (Jrev - Jfd) : 2.349831e-11
    Absolute Error (Jfor - Jrev): 2.220446e-16

    Relative Error (Jfor - Jfd) / Jfd : 2.326472e-11
    Relative Error (Jrev - Jfd) / Jfd : 2.326450e-11
    Relative Error (Jfor - Jrev) / Jfd: 2.198352e-16

    Raw Forward Derivative (Jfor)
[[1.01005017]]

    Raw Reverse Derivative (Jrev)
[[1.01005017]]

    Raw FD Derivative (Jfd)
[[1.01005017]]

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
_ test_time_integration_with_parameter_partials[PID-ImprovedErrorEstimator-AllCheckpointer-butcher_tableau0-1.0-TestComp1-0.0] _

test_class = <class 'tests.test_components.TestComp1'>, initial_time = 0.0
parameter = 1.0
butcher_tableau = <rkopenmdao.butcher_tableau.EmbeddedButcherTableau object at 0x15551f7d7ee0>
checkpointing_implementation = <class 'rkopenmdao.checkpoint_interface.all_checkpointer.AllCheckpointer'>
test_estimator = <class 'rkopenmdao.error_estimator.ImprovedErrorEstimator'>
test_controller = <function PID at 0x1555201d5550>

    @pytest.mark.rk
    @pytest.mark.rk_openmdao
    @pytest.mark.parametrize(
        "test_class, initial_time",
        (
            [TestComp1, 0.0],
            [TestComp1, 1.0],
        ),
    )
    @pytest.mark.parametrize("parameter", [1.0])
    @pytest.mark.parametrize(
        "butcher_tableau",
        [
            heun_euler,
            two_stage_dirk,
            three_stage_esdirk,
            four_stage_esdirk,
            five_stage_esdirk
        ]
    )
    @pytest.mark.parametrize(
        "checkpointing_implementation",
        [
            NoCheckpointer,
            AllCheckpointer,
        ],
    )
    @pytest.mark.parametrize(
        "test_estimator",
        [
            SimpleErrorEstimator,
            ImprovedErrorEstimator
        ]
    )
    @pytest.mark.parametrize(
        "test_controller",
        [
            Integral,
            H0_110,
            PID
        ]
    )
    def test_time_integration_with_parameter_partials(
        test_class, initial_time, parameter, butcher_tableau, checkpointing_implementation, test_estimator, test_controller
    ):
        """Tests the partials of the time integration of the different components."""
        termination_criterion = TerminationCriterion('end_time', initial_time + 0.01)
        integration_control = IntegrationControl(initial_time, termination_criterion, 0.001)
        time_integration_prob = om.Problem()
        time_integration_prob.model.add_subsystem(
            "test_comp", test_class(integration_control=integration_control)
        )
    
        time_integration_prob.model.nonlinear_solver = om.NewtonSolver(
            solve_subsystems=True
        )
        time_integration_prob.model.linear_solver = om.ScipyKrylov()
    
        runge_kutta_prob = om.Problem()
        runge_kutta_prob.model.add_subsystem(
            "rk_integrator",
            RungeKuttaIntegrator(
                time_stage_problem=time_integration_prob,
                butcher_tableau=butcher_tableau,
                integration_control=integration_control,
                time_integration_quantities=["x"],
                time_independent_input_quantities=["b"],
                checkpointing_type=checkpointing_implementation,
                error_controller=test_controller,
                error_estimator_type=test_estimator,
                adaptive_time_stepping=True,
            ),
            promotes=["*"],
        )
    
        runge_kutta_prob.setup()
        runge_kutta_prob["b"] = parameter
        runge_kutta_prob.run_model()
        if checkpointing_implementation == NoCheckpointer:
            with pytest.raises(NotImplementedError):
                runge_kutta_prob.check_partials(excludes=["Jfd","fd","Jfor-Jfd","Jrev-Jfd"])
        else:
            data = runge_kutta_prob.check_partials()
>           assert_check_partials(data)

test_component_test_adaptive.py:517: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = {'rk_integrator': {('x_final', 'b'): {'J_fd': array([[0.01010044]]), 'J_fwd': array([[0.01010041]]), 'J_rev': array([[...ErrorTuple(forward=7.500002840998832e-09, reverse=7.500003063043437e-09, forward_reverse=2.220446049250313e-16), ...}}}
atol = 1e-06, rtol = 1e-06

    def assert_check_partials(data, atol=1e-6, rtol=1e-6):
        """
        Raise assertion if any entry from the return from check_partials is above a tolerance.
    
        Parameters
        ----------
        data : dict of dicts of dicts
                First key:
                    is the component name;
                Second key:
                    is the (output, input) tuple of strings;
                Third key:
                    is one of ['rel error', 'abs error', 'magnitude', 'J_fd', 'J_fwd', 'J_rev'];
    
                For 'rel error', 'abs error', 'magnitude' the value is: A tuple containing norms for
                    forward - fd, adjoint - fd, forward - adjoint.
                For 'J_fd', 'J_fwd', 'J_rev' the value is: A numpy array representing the computed
                    Jacobian for the three different methods of computation.
        atol : float
            absolute error. Default is 1e-6.
        rtol : float
            relative error. Default is 1e-6.
        """
        error_string = ''
        absrel_header = 'abs/rel'
        wrt_header = '< output > wrt < variable >'
        norm_value_header = 'norm value'
        len_absrel_width = len(absrel_header)
        norm_types = ['fwd-fd', 'rev-fd', 'fd-rev']
        len_norm_type_width = max(len(s) for s in norm_types)
    
        for comp in data:
            len_wrt_width = len(wrt_header)
            len_norm_width = len(norm_value_header)
            bad_derivs = []
    
            # Find all derivatives whose errors exceed tolerance.
            # Also, size the output to precompute column extents.
            for (var, wrt) in data[comp]:
                pair_data = data[comp][var, wrt]
                for error_type, tolerance in [('abs error', atol), ('rel error', rtol), ]:
                    actual = pair_data[error_type]
                    for error_val, mode in zip(actual, norm_types):
                        in_error = False
    
                        if error_val is None:
                            # Reverse derivatives only computed on matrix free comps.
                            continue
    
                        if not np.isnan(error_val):
                            if not np.allclose(error_val, 0.0, atol=tolerance):
    
                                if error_type == 'rel error' and mode == 'fwd-fd' and \
                                   np.allclose(pair_data['J_fwd'], 0.0, atol=atol) and \
                                   np.allclose(pair_data['J_fd'], 0.0, atol=atol):
                                    # Special case: both fd and fwd are really tiny, so we want to
                                    # ignore the rather large relative errors.
                                    in_error = False
                                else:
                                    # This is a bona-fide error.
                                    in_error = True
    
                        elif error_type == 'abs error' and mode == 'fwd-fd':
                            # Either analytic or approximated derivatives contain a NaN.
                            in_error = True
    
                        if in_error:
                            wrt_string = '{0} wrt {1}'.format(var, wrt)
                            norm_string = '{}'.format(error_val)
                            bad_derivs.append((wrt_string, norm_string, error_type, mode))
                            len_wrt_width = max(len_wrt_width, len(wrt_string))
                            len_norm_width = max(len_norm_width, len(norm_string))
    
            if bad_derivs:
                comp_error_string = ''
                for wrt_string, norm_string, error_type, mode in bad_derivs:
                    err_msg = '{0} | {1} | {2} | {3}'.format(
                        pad_name(wrt_string, len_wrt_width),
                        pad_name(error_type.split()[0], len_absrel_width),
                        pad_name(mode, len_norm_type_width),
                        pad_name(norm_string, len_norm_width)) + '\n'
                    comp_error_string += err_msg
    
                name_header = 'Component: {}\n'.format(comp)
                len_name_header = len(name_header)
                header = len_name_header * '-' + '\n'
                header += name_header
                header += len_name_header * '-' + '\n'
                header += '{0} | {1} | {2} | {3}'.format(
                    pad_name(wrt_header, len_wrt_width),
                    pad_name(absrel_header, len_absrel_width),
                    pad_name('norm', len_norm_type_width),
                    pad_name(norm_value_header, len_norm_width),
                ) + '\n'
                header += '{0} | {1} | {2} | {3}'.format(
                    len_wrt_width * '-',
                    len_absrel_width * '-',
                    len_norm_type_width * '-',
                    len_norm_width * '-',
                ) + '\n'
                comp_error_string = header + comp_error_string
                error_string += comp_error_string
    
        # if error string then raise error with that string
        if error_string:
            header_line1 = 'Assert Check Partials failed for the following Components'
            header_line2 = 'with absolute tolerance = {} and relative tolerance = {}'.format(atol, rtol)
            header_width = max(len(header_line1), len(header_line2))
            header = '\n' + header_width * '=' + '\n'
            header += header_line1 + '\n'
            header += header_line2 + '\n'
            header += header_width * '=' + '\n'
            error_string = header + error_string
>           raise ValueError(error_string)
E           ValueError: 
E           ==============================================================
E           Assert Check Partials failed for the following Components
E           with absolute tolerance = 1e-06 and relative tolerance = 1e-06
E           ==============================================================
E           -------------------------
E           Component: rk_integrator
E           -------------------------
E           < output > wrt < variable > | abs/rel | norm   | norm value            
E           --------------------------- | ------- | ------ | ----------------------
E           x_final wrt b               | rel     | fwd-fd | 2.9434820642440056e-06
E           x_final wrt b               | rel     | rev-fd | 2.9434820645875e-06

/home/shuv_im/.spack/rev.23.05/install/linux-rocky8-zen2/gcc-10.4.0/py-openmdao-3.9.1-dlr.6-w57zdo/lib/python3.9/site-packages/openmdao/utils/assert_utils.py:225: ValueError
----------------------------- Captured stdout call -----------------------------


Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting fwd-mode jacvec product


Resetting error estimator.


Starting step 1 of fwd-mode jacvec product.
Time = 0.0, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 1.
Starting stage 2 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 1.

Finished step 1 of fwd-mode jacvec product.


Starting step 2 of fwd-mode jacvec product.
Time = 0.001, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 2.
Starting stage 2 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 2.

Finished step 2 of fwd-mode jacvec product.


Starting step 3 of fwd-mode jacvec product.
Time = 0.002506087194661843, dTime = 0.0015060871946618426.

Starting stage 1 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 3.
Starting stage 2 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 3.

Finished step 3 of fwd-mode jacvec product.


Starting step 4 of fwd-mode jacvec product.
Time = 0.007953448567336482, dTime = 0.005447361372674639.

Starting stage 1 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 4.
Starting stage 2 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 4.

Finished step 4 of fwd-mode jacvec product.



Finished fwd-mode jacvec product




Starting fwd-mode jacvec product


Resetting error estimator.


Starting step 1 of fwd-mode jacvec product.
Time = 0.0, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 1.
Starting stage 2 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 1.

Finished step 1 of fwd-mode jacvec product.


Starting step 2 of fwd-mode jacvec product.
Time = 0.001, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 2.
Starting stage 2 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 2.

Finished step 2 of fwd-mode jacvec product.


Starting step 3 of fwd-mode jacvec product.
Time = 0.002506087194661843, dTime = 0.0015060871946618426.

Starting stage 1 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 3.
Starting stage 2 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 3.

Finished step 3 of fwd-mode jacvec product.


Starting step 4 of fwd-mode jacvec product.
Time = 0.007953448567336482, dTime = 0.005447361372674639.

Starting stage 1 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 4.
Starting stage 2 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 4.

Finished step 4 of fwd-mode jacvec product.



Finished fwd-mode jacvec product




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting rev-mode jacvec product



Starting step 4 of rev-mode jacvec product.
Time = 0.007953448567336482, dTime = 0.0020465514326635185.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 4.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 4.

Finishing step 4 of rev-mode jacvec product.


Starting step 3 of rev-mode jacvec product.
Time = 0.002506087194661843, dTime = 0.005447361372674639.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 3.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 3.

Finishing step 3 of rev-mode jacvec product.


Starting step 2 of rev-mode jacvec product.
Time = 0.001, dTime = 0.0015060871946618426.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 2.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 2.

Finishing step 2 of rev-mode jacvec product.


Starting step 1 of rev-mode jacvec product.
Time = 0.0, dTime = 0.001.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 1.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 1.

Finishing step 1 of rev-mode jacvec product.



Finished rev-mode jacvec product




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute


-----------------------------------------------
Component: RungeKuttaIntegrator 'rk_integrator'
-----------------------------------------------
  rk_integrator: 'x_final' wrt 'b'
     Forward Magnitude: 1.010041e-02
     Reverse Magnitude: 1.010041e-02
          Fd Magnitude: 1.010044e-02 (fd:forward)
    Absolute Error (Jfor - Jfd) : 2.973047e-08
    Absolute Error (Jrev - Jfd) : 2.973047e-08
    Absolute Error (Jfor - Jrev): 3.469447e-18

    Relative Error (Jfor - Jfd) / Jfd : 2.943482e-06 *
    Relative Error (Jrev - Jfd) / Jfd : 2.943482e-06 *
    Relative Error (Jfor - Jrev) / Jfd: 3.434945e-16

    Raw Forward Derivative (Jfor)
[[0.01010041]]

    Raw Reverse Derivative (Jrev)
[[0.01010041]]

    Raw FD Derivative (Jfd)
[[0.01010044]]

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  rk_integrator: 'x_final' wrt 'x_initial'
     Forward Magnitude: 1.010050e+00
     Reverse Magnitude: 1.010050e+00
          Fd Magnitude: 1.010050e+00 (fd:forward)
    Absolute Error (Jfor - Jfd) : 7.500003e-09
    Absolute Error (Jrev - Jfd) : 7.500003e-09
    Absolute Error (Jfor - Jrev): 2.220446e-16

    Relative Error (Jfor - Jfd) / Jfd : 7.425377e-09
    Relative Error (Jrev - Jfd) / Jfd : 7.425377e-09
    Relative Error (Jfor - Jrev) / Jfd: 2.198352e-16

    Raw Forward Derivative (Jfor)
[[1.01005014]]

    Raw Reverse Derivative (Jrev)
[[1.01005014]]

    Raw FD Derivative (Jfd)
[[1.01005015]]

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
_ test_time_integration_with_parameter_partials[PID-ImprovedErrorEstimator-AllCheckpointer-butcher_tableau0-1.0-TestComp1-1.0] _

test_class = <class 'tests.test_components.TestComp1'>, initial_time = 1.0
parameter = 1.0
butcher_tableau = <rkopenmdao.butcher_tableau.EmbeddedButcherTableau object at 0x15551f7d7ee0>
checkpointing_implementation = <class 'rkopenmdao.checkpoint_interface.all_checkpointer.AllCheckpointer'>
test_estimator = <class 'rkopenmdao.error_estimator.ImprovedErrorEstimator'>
test_controller = <function PID at 0x1555201d5550>

    @pytest.mark.rk
    @pytest.mark.rk_openmdao
    @pytest.mark.parametrize(
        "test_class, initial_time",
        (
            [TestComp1, 0.0],
            [TestComp1, 1.0],
        ),
    )
    @pytest.mark.parametrize("parameter", [1.0])
    @pytest.mark.parametrize(
        "butcher_tableau",
        [
            heun_euler,
            two_stage_dirk,
            three_stage_esdirk,
            four_stage_esdirk,
            five_stage_esdirk
        ]
    )
    @pytest.mark.parametrize(
        "checkpointing_implementation",
        [
            NoCheckpointer,
            AllCheckpointer,
        ],
    )
    @pytest.mark.parametrize(
        "test_estimator",
        [
            SimpleErrorEstimator,
            ImprovedErrorEstimator
        ]
    )
    @pytest.mark.parametrize(
        "test_controller",
        [
            Integral,
            H0_110,
            PID
        ]
    )
    def test_time_integration_with_parameter_partials(
        test_class, initial_time, parameter, butcher_tableau, checkpointing_implementation, test_estimator, test_controller
    ):
        """Tests the partials of the time integration of the different components."""
        termination_criterion = TerminationCriterion('end_time', initial_time + 0.01)
        integration_control = IntegrationControl(initial_time, termination_criterion, 0.001)
        time_integration_prob = om.Problem()
        time_integration_prob.model.add_subsystem(
            "test_comp", test_class(integration_control=integration_control)
        )
    
        time_integration_prob.model.nonlinear_solver = om.NewtonSolver(
            solve_subsystems=True
        )
        time_integration_prob.model.linear_solver = om.ScipyKrylov()
    
        runge_kutta_prob = om.Problem()
        runge_kutta_prob.model.add_subsystem(
            "rk_integrator",
            RungeKuttaIntegrator(
                time_stage_problem=time_integration_prob,
                butcher_tableau=butcher_tableau,
                integration_control=integration_control,
                time_integration_quantities=["x"],
                time_independent_input_quantities=["b"],
                checkpointing_type=checkpointing_implementation,
                error_controller=test_controller,
                error_estimator_type=test_estimator,
                adaptive_time_stepping=True,
            ),
            promotes=["*"],
        )
    
        runge_kutta_prob.setup()
        runge_kutta_prob["b"] = parameter
        runge_kutta_prob.run_model()
        if checkpointing_implementation == NoCheckpointer:
            with pytest.raises(NotImplementedError):
                runge_kutta_prob.check_partials(excludes=["Jfd","fd","Jfor-Jfd","Jrev-Jfd"])
        else:
            data = runge_kutta_prob.check_partials()
>           assert_check_partials(data)

test_component_test_adaptive.py:517: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = {'rk_integrator': {('x_final', 'b'): {'J_fd': array([[0.01010044]]), 'J_fwd': array([[0.01010041]]), 'J_rev': array([[...ErrorTuple(forward=7.500002840998832e-09, reverse=7.500003063043437e-09, forward_reverse=2.220446049250313e-16), ...}}}
atol = 1e-06, rtol = 1e-06

    def assert_check_partials(data, atol=1e-6, rtol=1e-6):
        """
        Raise assertion if any entry from the return from check_partials is above a tolerance.
    
        Parameters
        ----------
        data : dict of dicts of dicts
                First key:
                    is the component name;
                Second key:
                    is the (output, input) tuple of strings;
                Third key:
                    is one of ['rel error', 'abs error', 'magnitude', 'J_fd', 'J_fwd', 'J_rev'];
    
                For 'rel error', 'abs error', 'magnitude' the value is: A tuple containing norms for
                    forward - fd, adjoint - fd, forward - adjoint.
                For 'J_fd', 'J_fwd', 'J_rev' the value is: A numpy array representing the computed
                    Jacobian for the three different methods of computation.
        atol : float
            absolute error. Default is 1e-6.
        rtol : float
            relative error. Default is 1e-6.
        """
        error_string = ''
        absrel_header = 'abs/rel'
        wrt_header = '< output > wrt < variable >'
        norm_value_header = 'norm value'
        len_absrel_width = len(absrel_header)
        norm_types = ['fwd-fd', 'rev-fd', 'fd-rev']
        len_norm_type_width = max(len(s) for s in norm_types)
    
        for comp in data:
            len_wrt_width = len(wrt_header)
            len_norm_width = len(norm_value_header)
            bad_derivs = []
    
            # Find all derivatives whose errors exceed tolerance.
            # Also, size the output to precompute column extents.
            for (var, wrt) in data[comp]:
                pair_data = data[comp][var, wrt]
                for error_type, tolerance in [('abs error', atol), ('rel error', rtol), ]:
                    actual = pair_data[error_type]
                    for error_val, mode in zip(actual, norm_types):
                        in_error = False
    
                        if error_val is None:
                            # Reverse derivatives only computed on matrix free comps.
                            continue
    
                        if not np.isnan(error_val):
                            if not np.allclose(error_val, 0.0, atol=tolerance):
    
                                if error_type == 'rel error' and mode == 'fwd-fd' and \
                                   np.allclose(pair_data['J_fwd'], 0.0, atol=atol) and \
                                   np.allclose(pair_data['J_fd'], 0.0, atol=atol):
                                    # Special case: both fd and fwd are really tiny, so we want to
                                    # ignore the rather large relative errors.
                                    in_error = False
                                else:
                                    # This is a bona-fide error.
                                    in_error = True
    
                        elif error_type == 'abs error' and mode == 'fwd-fd':
                            # Either analytic or approximated derivatives contain a NaN.
                            in_error = True
    
                        if in_error:
                            wrt_string = '{0} wrt {1}'.format(var, wrt)
                            norm_string = '{}'.format(error_val)
                            bad_derivs.append((wrt_string, norm_string, error_type, mode))
                            len_wrt_width = max(len_wrt_width, len(wrt_string))
                            len_norm_width = max(len_norm_width, len(norm_string))
    
            if bad_derivs:
                comp_error_string = ''
                for wrt_string, norm_string, error_type, mode in bad_derivs:
                    err_msg = '{0} | {1} | {2} | {3}'.format(
                        pad_name(wrt_string, len_wrt_width),
                        pad_name(error_type.split()[0], len_absrel_width),
                        pad_name(mode, len_norm_type_width),
                        pad_name(norm_string, len_norm_width)) + '\n'
                    comp_error_string += err_msg
    
                name_header = 'Component: {}\n'.format(comp)
                len_name_header = len(name_header)
                header = len_name_header * '-' + '\n'
                header += name_header
                header += len_name_header * '-' + '\n'
                header += '{0} | {1} | {2} | {3}'.format(
                    pad_name(wrt_header, len_wrt_width),
                    pad_name(absrel_header, len_absrel_width),
                    pad_name('norm', len_norm_type_width),
                    pad_name(norm_value_header, len_norm_width),
                ) + '\n'
                header += '{0} | {1} | {2} | {3}'.format(
                    len_wrt_width * '-',
                    len_absrel_width * '-',
                    len_norm_type_width * '-',
                    len_norm_width * '-',
                ) + '\n'
                comp_error_string = header + comp_error_string
                error_string += comp_error_string
    
        # if error string then raise error with that string
        if error_string:
            header_line1 = 'Assert Check Partials failed for the following Components'
            header_line2 = 'with absolute tolerance = {} and relative tolerance = {}'.format(atol, rtol)
            header_width = max(len(header_line1), len(header_line2))
            header = '\n' + header_width * '=' + '\n'
            header += header_line1 + '\n'
            header += header_line2 + '\n'
            header += header_width * '=' + '\n'
            error_string = header + error_string
>           raise ValueError(error_string)
E           ValueError: 
E           ==============================================================
E           Assert Check Partials failed for the following Components
E           with absolute tolerance = 1e-06 and relative tolerance = 1e-06
E           ==============================================================
E           -------------------------
E           Component: rk_integrator
E           -------------------------
E           < output > wrt < variable > | abs/rel | norm   | norm value            
E           --------------------------- | ------- | ------ | ----------------------
E           x_final wrt b               | rel     | fwd-fd | 2.9654656476743477e-06
E           x_final wrt b               | rel     | rev-fd | 2.965465648017842e-06

/home/shuv_im/.spack/rev.23.05/install/linux-rocky8-zen2/gcc-10.4.0/py-openmdao-3.9.1-dlr.6-w57zdo/lib/python3.9/site-packages/openmdao/utils/assert_utils.py:225: ValueError
----------------------------- Captured stdout call -----------------------------


Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting fwd-mode jacvec product


Resetting error estimator.


Starting step 1 of fwd-mode jacvec product.
Time = 1.0, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 1.
Starting stage 2 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 1.

Finished step 1 of fwd-mode jacvec product.


Starting step 2 of fwd-mode jacvec product.
Time = 1.001, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 2.
Starting stage 2 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 2.

Finished step 2 of fwd-mode jacvec product.


Starting step 3 of fwd-mode jacvec product.
Time = 1.0025060871946618, dTime = 0.0015060871946618426.

Starting stage 1 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 3.
Starting stage 2 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 3.

Finished step 3 of fwd-mode jacvec product.


Starting step 4 of fwd-mode jacvec product.
Time = 1.0079534485673365, dTime = 0.005447361372674639.

Starting stage 1 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 4.
Starting stage 2 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 4.

Finished step 4 of fwd-mode jacvec product.



Finished fwd-mode jacvec product




Starting fwd-mode jacvec product


Resetting error estimator.


Starting step 1 of fwd-mode jacvec product.
Time = 1.0, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 1.
Starting stage 2 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 1.

Finished step 1 of fwd-mode jacvec product.


Starting step 2 of fwd-mode jacvec product.
Time = 1.001, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 2.
Starting stage 2 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 2.

Finished step 2 of fwd-mode jacvec product.


Starting step 3 of fwd-mode jacvec product.
Time = 1.0025060871946618, dTime = 0.0015060871946618426.

Starting stage 1 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 3.
Starting stage 2 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 3.

Finished step 3 of fwd-mode jacvec product.


Starting step 4 of fwd-mode jacvec product.
Time = 1.0079534485673365, dTime = 0.005447361372674639.

Starting stage 1 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 4.
Starting stage 2 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 4.

Finished step 4 of fwd-mode jacvec product.



Finished fwd-mode jacvec product




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting rev-mode jacvec product



Starting step 4 of rev-mode jacvec product.
Time = 1.0079534485673365, dTime = 0.0020465514326635237.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 4.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 4.

Finishing step 4 of rev-mode jacvec product.


Starting step 3 of rev-mode jacvec product.
Time = 1.0025060871946618, dTime = 0.005447361372674639.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 3.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 3.

Finishing step 3 of rev-mode jacvec product.


Starting step 2 of rev-mode jacvec product.
Time = 1.001, dTime = 0.0015060871946618426.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 2.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 2.

Finishing step 2 of rev-mode jacvec product.


Starting step 1 of rev-mode jacvec product.
Time = 1.0, dTime = 0.001.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 1.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 1.

Finishing step 1 of rev-mode jacvec product.



Finished rev-mode jacvec product




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute


-----------------------------------------------
Component: RungeKuttaIntegrator 'rk_integrator'
-----------------------------------------------
  rk_integrator: 'x_final' wrt 'b'
     Forward Magnitude: 1.010041e-02
     Reverse Magnitude: 1.010041e-02
          Fd Magnitude: 1.010044e-02 (fd:forward)
    Absolute Error (Jfor - Jfd) : 2.995252e-08
    Absolute Error (Jrev - Jfd) : 2.995252e-08
    Absolute Error (Jfor - Jrev): 3.469447e-18

    Relative Error (Jfor - Jfd) / Jfd : 2.965466e-06 *
    Relative Error (Jrev - Jfd) / Jfd : 2.965466e-06 *
    Relative Error (Jfor - Jrev) / Jfd: 3.434945e-16

    Raw Forward Derivative (Jfor)
[[0.01010041]]

    Raw Reverse Derivative (Jrev)
[[0.01010041]]

    Raw FD Derivative (Jfd)
[[0.01010044]]

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  rk_integrator: 'x_final' wrt 'x_initial'
     Forward Magnitude: 1.010050e+00
     Reverse Magnitude: 1.010050e+00
          Fd Magnitude: 1.010050e+00 (fd:forward)
    Absolute Error (Jfor - Jfd) : 7.500003e-09
    Absolute Error (Jrev - Jfd) : 7.500003e-09
    Absolute Error (Jfor - Jrev): 2.220446e-16

    Relative Error (Jfor - Jfd) / Jfd : 7.425377e-09
    Relative Error (Jrev - Jfd) / Jfd : 7.425377e-09
    Relative Error (Jfor - Jrev) / Jfd: 2.198352e-16

    Raw Forward Derivative (Jfor)
[[1.01005014]]

    Raw Reverse Derivative (Jrev)
[[1.01005014]]

    Raw FD Derivative (Jfd)
[[1.01005015]]

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
_ test_time_integration_with_parameter_partials[PID-ImprovedErrorEstimator-AllCheckpointer-butcher_tableau1-1.0-TestComp1-0.0] _

test_class = <class 'tests.test_components.TestComp1'>, initial_time = 0.0
parameter = 1.0
butcher_tableau = <rkopenmdao.butcher_tableau.EmbeddedButcherTableau object at 0x15551f7d7f40>
checkpointing_implementation = <class 'rkopenmdao.checkpoint_interface.all_checkpointer.AllCheckpointer'>
test_estimator = <class 'rkopenmdao.error_estimator.ImprovedErrorEstimator'>
test_controller = <function PID at 0x1555201d5550>

    @pytest.mark.rk
    @pytest.mark.rk_openmdao
    @pytest.mark.parametrize(
        "test_class, initial_time",
        (
            [TestComp1, 0.0],
            [TestComp1, 1.0],
        ),
    )
    @pytest.mark.parametrize("parameter", [1.0])
    @pytest.mark.parametrize(
        "butcher_tableau",
        [
            heun_euler,
            two_stage_dirk,
            three_stage_esdirk,
            four_stage_esdirk,
            five_stage_esdirk
        ]
    )
    @pytest.mark.parametrize(
        "checkpointing_implementation",
        [
            NoCheckpointer,
            AllCheckpointer,
        ],
    )
    @pytest.mark.parametrize(
        "test_estimator",
        [
            SimpleErrorEstimator,
            ImprovedErrorEstimator
        ]
    )
    @pytest.mark.parametrize(
        "test_controller",
        [
            Integral,
            H0_110,
            PID
        ]
    )
    def test_time_integration_with_parameter_partials(
        test_class, initial_time, parameter, butcher_tableau, checkpointing_implementation, test_estimator, test_controller
    ):
        """Tests the partials of the time integration of the different components."""
        termination_criterion = TerminationCriterion('end_time', initial_time + 0.01)
        integration_control = IntegrationControl(initial_time, termination_criterion, 0.001)
        time_integration_prob = om.Problem()
        time_integration_prob.model.add_subsystem(
            "test_comp", test_class(integration_control=integration_control)
        )
    
        time_integration_prob.model.nonlinear_solver = om.NewtonSolver(
            solve_subsystems=True
        )
        time_integration_prob.model.linear_solver = om.ScipyKrylov()
    
        runge_kutta_prob = om.Problem()
        runge_kutta_prob.model.add_subsystem(
            "rk_integrator",
            RungeKuttaIntegrator(
                time_stage_problem=time_integration_prob,
                butcher_tableau=butcher_tableau,
                integration_control=integration_control,
                time_integration_quantities=["x"],
                time_independent_input_quantities=["b"],
                checkpointing_type=checkpointing_implementation,
                error_controller=test_controller,
                error_estimator_type=test_estimator,
                adaptive_time_stepping=True,
            ),
            promotes=["*"],
        )
    
        runge_kutta_prob.setup()
        runge_kutta_prob["b"] = parameter
        runge_kutta_prob.run_model()
        if checkpointing_implementation == NoCheckpointer:
            with pytest.raises(NotImplementedError):
                runge_kutta_prob.check_partials(excludes=["Jfd","fd","Jfor-Jfd","Jrev-Jfd"])
        else:
            data = runge_kutta_prob.check_partials()
>           assert_check_partials(data)

test_component_test_adaptive.py:517: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = {'rk_integrator': {('x_final', 'b'): {'J_fd': array([[0.01008452]]), 'J_fwd': array([[0.01008454]]), 'J_rev': array([[...rrorTuple(forward=4.862851676890045e-09, reverse=4.8628514548454405e-09, forward_reverse=2.220446049250313e-16), ...}}}
atol = 1e-06, rtol = 1e-06

    def assert_check_partials(data, atol=1e-6, rtol=1e-6):
        """
        Raise assertion if any entry from the return from check_partials is above a tolerance.
    
        Parameters
        ----------
        data : dict of dicts of dicts
                First key:
                    is the component name;
                Second key:
                    is the (output, input) tuple of strings;
                Third key:
                    is one of ['rel error', 'abs error', 'magnitude', 'J_fd', 'J_fwd', 'J_rev'];
    
                For 'rel error', 'abs error', 'magnitude' the value is: A tuple containing norms for
                    forward - fd, adjoint - fd, forward - adjoint.
                For 'J_fd', 'J_fwd', 'J_rev' the value is: A numpy array representing the computed
                    Jacobian for the three different methods of computation.
        atol : float
            absolute error. Default is 1e-6.
        rtol : float
            relative error. Default is 1e-6.
        """
        error_string = ''
        absrel_header = 'abs/rel'
        wrt_header = '< output > wrt < variable >'
        norm_value_header = 'norm value'
        len_absrel_width = len(absrel_header)
        norm_types = ['fwd-fd', 'rev-fd', 'fd-rev']
        len_norm_type_width = max(len(s) for s in norm_types)
    
        for comp in data:
            len_wrt_width = len(wrt_header)
            len_norm_width = len(norm_value_header)
            bad_derivs = []
    
            # Find all derivatives whose errors exceed tolerance.
            # Also, size the output to precompute column extents.
            for (var, wrt) in data[comp]:
                pair_data = data[comp][var, wrt]
                for error_type, tolerance in [('abs error', atol), ('rel error', rtol), ]:
                    actual = pair_data[error_type]
                    for error_val, mode in zip(actual, norm_types):
                        in_error = False
    
                        if error_val is None:
                            # Reverse derivatives only computed on matrix free comps.
                            continue
    
                        if not np.isnan(error_val):
                            if not np.allclose(error_val, 0.0, atol=tolerance):
    
                                if error_type == 'rel error' and mode == 'fwd-fd' and \
                                   np.allclose(pair_data['J_fwd'], 0.0, atol=atol) and \
                                   np.allclose(pair_data['J_fd'], 0.0, atol=atol):
                                    # Special case: both fd and fwd are really tiny, so we want to
                                    # ignore the rather large relative errors.
                                    in_error = False
                                else:
                                    # This is a bona-fide error.
                                    in_error = True
    
                        elif error_type == 'abs error' and mode == 'fwd-fd':
                            # Either analytic or approximated derivatives contain a NaN.
                            in_error = True
    
                        if in_error:
                            wrt_string = '{0} wrt {1}'.format(var, wrt)
                            norm_string = '{}'.format(error_val)
                            bad_derivs.append((wrt_string, norm_string, error_type, mode))
                            len_wrt_width = max(len_wrt_width, len(wrt_string))
                            len_norm_width = max(len_norm_width, len(norm_string))
    
            if bad_derivs:
                comp_error_string = ''
                for wrt_string, norm_string, error_type, mode in bad_derivs:
                    err_msg = '{0} | {1} | {2} | {3}'.format(
                        pad_name(wrt_string, len_wrt_width),
                        pad_name(error_type.split()[0], len_absrel_width),
                        pad_name(mode, len_norm_type_width),
                        pad_name(norm_string, len_norm_width)) + '\n'
                    comp_error_string += err_msg
    
                name_header = 'Component: {}\n'.format(comp)
                len_name_header = len(name_header)
                header = len_name_header * '-' + '\n'
                header += name_header
                header += len_name_header * '-' + '\n'
                header += '{0} | {1} | {2} | {3}'.format(
                    pad_name(wrt_header, len_wrt_width),
                    pad_name(absrel_header, len_absrel_width),
                    pad_name('norm', len_norm_type_width),
                    pad_name(norm_value_header, len_norm_width),
                ) + '\n'
                header += '{0} | {1} | {2} | {3}'.format(
                    len_wrt_width * '-',
                    len_absrel_width * '-',
                    len_norm_type_width * '-',
                    len_norm_width * '-',
                ) + '\n'
                comp_error_string = header + comp_error_string
                error_string += comp_error_string
    
        # if error string then raise error with that string
        if error_string:
            header_line1 = 'Assert Check Partials failed for the following Components'
            header_line2 = 'with absolute tolerance = {} and relative tolerance = {}'.format(atol, rtol)
            header_width = max(len(header_line1), len(header_line2))
            header = '\n' + header_width * '=' + '\n'
            header += header_line1 + '\n'
            header += header_line2 + '\n'
            header += header_width * '=' + '\n'
            error_string = header + error_string
>           raise ValueError(error_string)
E           ValueError: 
E           ==============================================================
E           Assert Check Partials failed for the following Components
E           with absolute tolerance = 1e-06 and relative tolerance = 1e-06
E           ==============================================================
E           -------------------------
E           Component: rk_integrator
E           -------------------------
E           < output > wrt < variable > | abs/rel | norm   | norm value            
E           --------------------------- | ------- | ------ | ----------------------
E           x_final wrt b               | rel     | fwd-fd | 1.9067098738196946e-06
E           x_final wrt b               | rel     | rev-fd | 1.9067098734756577e-06

/home/shuv_im/.spack/rev.23.05/install/linux-rocky8-zen2/gcc-10.4.0/py-openmdao-3.9.1-dlr.6-w57zdo/lib/python3.9/site-packages/openmdao/utils/assert_utils.py:225: ValueError
----------------------------- Captured stdout call -----------------------------


Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting fwd-mode jacvec product


Resetting error estimator.


Starting step 1 of fwd-mode jacvec product.
Time = 0.0, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 1.
Starting stage 2 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 1.

Finished step 1 of fwd-mode jacvec product.


Starting step 2 of fwd-mode jacvec product.
Time = 0.001, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 2.
Starting stage 2 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 2.

Finished step 2 of fwd-mode jacvec product.


Starting step 3 of fwd-mode jacvec product.
Time = 0.002612364548255441, dTime = 0.001612364548255441.

Starting stage 1 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 3.
Starting stage 2 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 3.

Finished step 3 of fwd-mode jacvec product.


Starting step 4 of fwd-mode jacvec product.
Time = 0.009713715293500437, dTime = 0.007101350745244996.

Starting stage 1 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 4.
Starting stage 2 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 4.

Finished step 4 of fwd-mode jacvec product.



Finished fwd-mode jacvec product




Starting fwd-mode jacvec product


Resetting error estimator.


Starting step 1 of fwd-mode jacvec product.
Time = 0.0, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 1.
Starting stage 2 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 1.

Finished step 1 of fwd-mode jacvec product.


Starting step 2 of fwd-mode jacvec product.
Time = 0.001, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 2.
Starting stage 2 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 2.

Finished step 2 of fwd-mode jacvec product.


Starting step 3 of fwd-mode jacvec product.
Time = 0.002612364548255441, dTime = 0.001612364548255441.

Starting stage 1 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 3.
Starting stage 2 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 3.

Finished step 3 of fwd-mode jacvec product.


Starting step 4 of fwd-mode jacvec product.
Time = 0.009713715293500437, dTime = 0.007101350745244996.

Starting stage 1 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 4.
Starting stage 2 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 4.

Finished step 4 of fwd-mode jacvec product.



Finished fwd-mode jacvec product




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting rev-mode jacvec product



Starting step 4 of rev-mode jacvec product.
Time = 0.009713715293500437, dTime = 0.0002862847064995632.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 4.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 4.

Finishing step 4 of rev-mode jacvec product.


Starting step 3 of rev-mode jacvec product.
Time = 0.002612364548255441, dTime = 0.007101350745244996.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 3.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 3.

Finishing step 3 of rev-mode jacvec product.


Starting step 2 of rev-mode jacvec product.
Time = 0.001, dTime = 0.001612364548255441.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 2.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 2.

Finishing step 2 of rev-mode jacvec product.


Starting step 1 of rev-mode jacvec product.
Time = 0.0, dTime = 0.001.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 1.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 1.

Finishing step 1 of rev-mode jacvec product.



Finished rev-mode jacvec product




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute


-----------------------------------------------
Component: RungeKuttaIntegrator 'rk_integrator'
-----------------------------------------------
  rk_integrator: 'x_final' wrt 'b'
     Forward Magnitude: 1.008454e-02
     Reverse Magnitude: 1.008454e-02
          Fd Magnitude: 1.008452e-02 (fd:forward)
    Absolute Error (Jfor - Jfd) : 1.922825e-08
    Absolute Error (Jrev - Jfd) : 1.922825e-08
    Absolute Error (Jfor - Jrev): 3.469447e-18

    Relative Error (Jfor - Jfd) / Jfd : 1.906710e-06 *
    Relative Error (Jrev - Jfd) / Jfd : 1.906710e-06 *
    Relative Error (Jfor - Jrev) / Jfd: 3.440369e-16

    Raw Forward Derivative (Jfor)
[[0.01008454]]

    Raw Reverse Derivative (Jrev)
[[0.01008454]]

    Raw FD Derivative (Jfd)
[[0.01008452]]

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  rk_integrator: 'x_final' wrt 'x_initial'
     Forward Magnitude: 1.010050e+00
     Reverse Magnitude: 1.010050e+00
          Fd Magnitude: 1.010050e+00 (fd:forward)
    Absolute Error (Jfor - Jfd) : 4.862852e-09
    Absolute Error (Jrev - Jfd) : 4.862851e-09
    Absolute Error (Jfor - Jrev): 2.220446e-16

    Relative Error (Jfor - Jfd) / Jfd : 4.814465e-09
    Relative Error (Jrev - Jfd) / Jfd : 4.814465e-09
    Relative Error (Jfor - Jrev) / Jfd: 2.198352e-16

    Raw Forward Derivative (Jfor)
[[1.01005018]]

    Raw Reverse Derivative (Jrev)
[[1.01005018]]

    Raw FD Derivative (Jfd)
[[1.01005018]]

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
_ test_time_integration_with_parameter_partials[PID-ImprovedErrorEstimator-AllCheckpointer-butcher_tableau1-1.0-TestComp1-1.0] _

test_class = <class 'tests.test_components.TestComp1'>, initial_time = 1.0
parameter = 1.0
butcher_tableau = <rkopenmdao.butcher_tableau.EmbeddedButcherTableau object at 0x15551f7d7f40>
checkpointing_implementation = <class 'rkopenmdao.checkpoint_interface.all_checkpointer.AllCheckpointer'>
test_estimator = <class 'rkopenmdao.error_estimator.ImprovedErrorEstimator'>
test_controller = <function PID at 0x1555201d5550>

    @pytest.mark.rk
    @pytest.mark.rk_openmdao
    @pytest.mark.parametrize(
        "test_class, initial_time",
        (
            [TestComp1, 0.0],
            [TestComp1, 1.0],
        ),
    )
    @pytest.mark.parametrize("parameter", [1.0])
    @pytest.mark.parametrize(
        "butcher_tableau",
        [
            heun_euler,
            two_stage_dirk,
            three_stage_esdirk,
            four_stage_esdirk,
            five_stage_esdirk
        ]
    )
    @pytest.mark.parametrize(
        "checkpointing_implementation",
        [
            NoCheckpointer,
            AllCheckpointer,
        ],
    )
    @pytest.mark.parametrize(
        "test_estimator",
        [
            SimpleErrorEstimator,
            ImprovedErrorEstimator
        ]
    )
    @pytest.mark.parametrize(
        "test_controller",
        [
            Integral,
            H0_110,
            PID
        ]
    )
    def test_time_integration_with_parameter_partials(
        test_class, initial_time, parameter, butcher_tableau, checkpointing_implementation, test_estimator, test_controller
    ):
        """Tests the partials of the time integration of the different components."""
        termination_criterion = TerminationCriterion('end_time', initial_time + 0.01)
        integration_control = IntegrationControl(initial_time, termination_criterion, 0.001)
        time_integration_prob = om.Problem()
        time_integration_prob.model.add_subsystem(
            "test_comp", test_class(integration_control=integration_control)
        )
    
        time_integration_prob.model.nonlinear_solver = om.NewtonSolver(
            solve_subsystems=True
        )
        time_integration_prob.model.linear_solver = om.ScipyKrylov()
    
        runge_kutta_prob = om.Problem()
        runge_kutta_prob.model.add_subsystem(
            "rk_integrator",
            RungeKuttaIntegrator(
                time_stage_problem=time_integration_prob,
                butcher_tableau=butcher_tableau,
                integration_control=integration_control,
                time_integration_quantities=["x"],
                time_independent_input_quantities=["b"],
                checkpointing_type=checkpointing_implementation,
                error_controller=test_controller,
                error_estimator_type=test_estimator,
                adaptive_time_stepping=True,
            ),
            promotes=["*"],
        )
    
        runge_kutta_prob.setup()
        runge_kutta_prob["b"] = parameter
        runge_kutta_prob.run_model()
        if checkpointing_implementation == NoCheckpointer:
            with pytest.raises(NotImplementedError):
                runge_kutta_prob.check_partials(excludes=["Jfd","fd","Jfor-Jfd","Jrev-Jfd"])
        else:
            data = runge_kutta_prob.check_partials()
>           assert_check_partials(data)

test_component_test_adaptive.py:517: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = {'rk_integrator': {('x_final', 'b'): {'J_fd': array([[0.01008452]]), 'J_fwd': array([[0.01008454]]), 'J_rev': array([[...]]), 'abs error': ErrorTuple(forward=4.640806849920409e-09, reverse=4.640806849920409e-09, forward_reverse=0.0), ...}}}
atol = 1e-06, rtol = 1e-06

    def assert_check_partials(data, atol=1e-6, rtol=1e-6):
        """
        Raise assertion if any entry from the return from check_partials is above a tolerance.
    
        Parameters
        ----------
        data : dict of dicts of dicts
                First key:
                    is the component name;
                Second key:
                    is the (output, input) tuple of strings;
                Third key:
                    is one of ['rel error', 'abs error', 'magnitude', 'J_fd', 'J_fwd', 'J_rev'];
    
                For 'rel error', 'abs error', 'magnitude' the value is: A tuple containing norms for
                    forward - fd, adjoint - fd, forward - adjoint.
                For 'J_fd', 'J_fwd', 'J_rev' the value is: A numpy array representing the computed
                    Jacobian for the three different methods of computation.
        atol : float
            absolute error. Default is 1e-6.
        rtol : float
            relative error. Default is 1e-6.
        """
        error_string = ''
        absrel_header = 'abs/rel'
        wrt_header = '< output > wrt < variable >'
        norm_value_header = 'norm value'
        len_absrel_width = len(absrel_header)
        norm_types = ['fwd-fd', 'rev-fd', 'fd-rev']
        len_norm_type_width = max(len(s) for s in norm_types)
    
        for comp in data:
            len_wrt_width = len(wrt_header)
            len_norm_width = len(norm_value_header)
            bad_derivs = []
    
            # Find all derivatives whose errors exceed tolerance.
            # Also, size the output to precompute column extents.
            for (var, wrt) in data[comp]:
                pair_data = data[comp][var, wrt]
                for error_type, tolerance in [('abs error', atol), ('rel error', rtol), ]:
                    actual = pair_data[error_type]
                    for error_val, mode in zip(actual, norm_types):
                        in_error = False
    
                        if error_val is None:
                            # Reverse derivatives only computed on matrix free comps.
                            continue
    
                        if not np.isnan(error_val):
                            if not np.allclose(error_val, 0.0, atol=tolerance):
    
                                if error_type == 'rel error' and mode == 'fwd-fd' and \
                                   np.allclose(pair_data['J_fwd'], 0.0, atol=atol) and \
                                   np.allclose(pair_data['J_fd'], 0.0, atol=atol):
                                    # Special case: both fd and fwd are really tiny, so we want to
                                    # ignore the rather large relative errors.
                                    in_error = False
                                else:
                                    # This is a bona-fide error.
                                    in_error = True
    
                        elif error_type == 'abs error' and mode == 'fwd-fd':
                            # Either analytic or approximated derivatives contain a NaN.
                            in_error = True
    
                        if in_error:
                            wrt_string = '{0} wrt {1}'.format(var, wrt)
                            norm_string = '{}'.format(error_val)
                            bad_derivs.append((wrt_string, norm_string, error_type, mode))
                            len_wrt_width = max(len_wrt_width, len(wrt_string))
                            len_norm_width = max(len_norm_width, len(norm_string))
    
            if bad_derivs:
                comp_error_string = ''
                for wrt_string, norm_string, error_type, mode in bad_derivs:
                    err_msg = '{0} | {1} | {2} | {3}'.format(
                        pad_name(wrt_string, len_wrt_width),
                        pad_name(error_type.split()[0], len_absrel_width),
                        pad_name(mode, len_norm_type_width),
                        pad_name(norm_string, len_norm_width)) + '\n'
                    comp_error_string += err_msg
    
                name_header = 'Component: {}\n'.format(comp)
                len_name_header = len(name_header)
                header = len_name_header * '-' + '\n'
                header += name_header
                header += len_name_header * '-' + '\n'
                header += '{0} | {1} | {2} | {3}'.format(
                    pad_name(wrt_header, len_wrt_width),
                    pad_name(absrel_header, len_absrel_width),
                    pad_name('norm', len_norm_type_width),
                    pad_name(norm_value_header, len_norm_width),
                ) + '\n'
                header += '{0} | {1} | {2} | {3}'.format(
                    len_wrt_width * '-',
                    len_absrel_width * '-',
                    len_norm_type_width * '-',
                    len_norm_width * '-',
                ) + '\n'
                comp_error_string = header + comp_error_string
                error_string += comp_error_string
    
        # if error string then raise error with that string
        if error_string:
            header_line1 = 'Assert Check Partials failed for the following Components'
            header_line2 = 'with absolute tolerance = {} and relative tolerance = {}'.format(atol, rtol)
            header_width = max(len(header_line1), len(header_line2))
            header = '\n' + header_width * '=' + '\n'
            header += header_line1 + '\n'
            header += header_line2 + '\n'
            header += header_width * '=' + '\n'
            error_string = header + error_string
>           raise ValueError(error_string)
E           ValueError: 
E           ==============================================================
E           Assert Check Partials failed for the following Components
E           with absolute tolerance = 1e-06 and relative tolerance = 1e-06
E           ==============================================================
E           -------------------------
E           Component: rk_integrator
E           -------------------------
E           < output > wrt < variable > | abs/rel | norm   | norm value            
E           --------------------------- | ------- | ------ | ----------------------
E           x_final wrt b               | rel     | fwd-fd | 1.8626730579303337e-06
E           x_final wrt b               | rel     | rev-fd | 1.8626730577583153e-06

/home/shuv_im/.spack/rev.23.05/install/linux-rocky8-zen2/gcc-10.4.0/py-openmdao-3.9.1-dlr.6-w57zdo/lib/python3.9/site-packages/openmdao/utils/assert_utils.py:225: ValueError
----------------------------- Captured stdout call -----------------------------


Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting fwd-mode jacvec product


Resetting error estimator.


Starting step 1 of fwd-mode jacvec product.
Time = 1.0, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 1.
Starting stage 2 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 1.

Finished step 1 of fwd-mode jacvec product.


Starting step 2 of fwd-mode jacvec product.
Time = 1.001, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 2.
Starting stage 2 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 2.

Finished step 2 of fwd-mode jacvec product.


Starting step 3 of fwd-mode jacvec product.
Time = 1.0026123645482554, dTime = 0.001612364548255441.

Starting stage 1 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 3.
Starting stage 2 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 3.

Finished step 3 of fwd-mode jacvec product.


Starting step 4 of fwd-mode jacvec product.
Time = 1.0097137152935005, dTime = 0.007101350745244996.

Starting stage 1 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 4.
Starting stage 2 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 4.

Finished step 4 of fwd-mode jacvec product.



Finished fwd-mode jacvec product




Starting fwd-mode jacvec product


Resetting error estimator.


Starting step 1 of fwd-mode jacvec product.
Time = 1.0, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 1.
Starting stage 2 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 1.

Finished step 1 of fwd-mode jacvec product.


Starting step 2 of fwd-mode jacvec product.
Time = 1.001, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 2.
Starting stage 2 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 2.

Finished step 2 of fwd-mode jacvec product.


Starting step 3 of fwd-mode jacvec product.
Time = 1.0026123645482554, dTime = 0.001612364548255441.

Starting stage 1 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 3.
Starting stage 2 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 3.

Finished step 3 of fwd-mode jacvec product.


Starting step 4 of fwd-mode jacvec product.
Time = 1.0097137152935005, dTime = 0.007101350745244996.

Starting stage 1 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 4.
Starting stage 2 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 4.

Finished step 4 of fwd-mode jacvec product.



Finished fwd-mode jacvec product




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting rev-mode jacvec product



Starting step 4 of rev-mode jacvec product.
Time = 1.0097137152935005, dTime = 0.00028628470649949556.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 4.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 4.

Finishing step 4 of rev-mode jacvec product.


Starting step 3 of rev-mode jacvec product.
Time = 1.0026123645482554, dTime = 0.007101350745244996.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 3.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 3.

Finishing step 3 of rev-mode jacvec product.


Starting step 2 of rev-mode jacvec product.
Time = 1.001, dTime = 0.001612364548255441.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 2.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 2.

Finishing step 2 of rev-mode jacvec product.


Starting step 1 of rev-mode jacvec product.
Time = 1.0, dTime = 0.001.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 1.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 1.

Finishing step 1 of rev-mode jacvec product.



Finished rev-mode jacvec product




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.

Finishing step 4 of compute.



Finishing compute


-----------------------------------------------
Component: RungeKuttaIntegrator 'rk_integrator'
-----------------------------------------------
  rk_integrator: 'x_final' wrt 'b'
     Forward Magnitude: 1.008454e-02
     Reverse Magnitude: 1.008454e-02
          Fd Magnitude: 1.008452e-02 (fd:forward)
    Absolute Error (Jfor - Jfd) : 1.878416e-08
    Absolute Error (Jrev - Jfd) : 1.878416e-08
    Absolute Error (Jfor - Jrev): 1.734723e-18

    Relative Error (Jfor - Jfd) / Jfd : 1.862673e-06 *
    Relative Error (Jrev - Jfd) / Jfd : 1.862673e-06 *
    Relative Error (Jfor - Jrev) / Jfd: 1.720185e-16

    Raw Forward Derivative (Jfor)
[[0.01008454]]

    Raw Reverse Derivative (Jrev)
[[0.01008454]]

    Raw FD Derivative (Jfd)
[[0.01008452]]

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  rk_integrator: 'x_final' wrt 'x_initial'
     Forward Magnitude: 1.010050e+00
     Reverse Magnitude: 1.010050e+00
          Fd Magnitude: 1.010050e+00 (fd:forward)
    Absolute Error (Jfor - Jfd) : 4.640807e-09
    Absolute Error (Jrev - Jfd) : 4.640807e-09
    Absolute Error (Jfor - Jrev): 0.000000e+00

    Relative Error (Jfor - Jfd) / Jfd : 4.594630e-09
    Relative Error (Jrev - Jfd) / Jfd : 4.594630e-09
    Relative Error (Jfor - Jrev) / Jfd: 0.000000e+00

    Raw Forward Derivative (Jfor)
[[1.01005018]]

    Raw Reverse Derivative (Jrev)
[[1.01005018]]

    Raw FD Derivative (Jfd)
[[1.01005018]]

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
_ test_time_integration_with_parameter_partials[PID-ImprovedErrorEstimator-AllCheckpointer-butcher_tableau3-1.0-TestComp1-0.0] _

test_class = <class 'tests.test_components.TestComp1'>, initial_time = 0.0
parameter = 1.0
butcher_tableau = <rkopenmdao.butcher_tableau.EmbeddedButcherTableau object at 0x15551f7d7fd0>
checkpointing_implementation = <class 'rkopenmdao.checkpoint_interface.all_checkpointer.AllCheckpointer'>
test_estimator = <class 'rkopenmdao.error_estimator.ImprovedErrorEstimator'>
test_controller = <function PID at 0x1555201d5550>

    @pytest.mark.rk
    @pytest.mark.rk_openmdao
    @pytest.mark.parametrize(
        "test_class, initial_time",
        (
            [TestComp1, 0.0],
            [TestComp1, 1.0],
        ),
    )
    @pytest.mark.parametrize("parameter", [1.0])
    @pytest.mark.parametrize(
        "butcher_tableau",
        [
            heun_euler,
            two_stage_dirk,
            three_stage_esdirk,
            four_stage_esdirk,
            five_stage_esdirk
        ]
    )
    @pytest.mark.parametrize(
        "checkpointing_implementation",
        [
            NoCheckpointer,
            AllCheckpointer,
        ],
    )
    @pytest.mark.parametrize(
        "test_estimator",
        [
            SimpleErrorEstimator,
            ImprovedErrorEstimator
        ]
    )
    @pytest.mark.parametrize(
        "test_controller",
        [
            Integral,
            H0_110,
            PID
        ]
    )
    def test_time_integration_with_parameter_partials(
        test_class, initial_time, parameter, butcher_tableau, checkpointing_implementation, test_estimator, test_controller
    ):
        """Tests the partials of the time integration of the different components."""
        termination_criterion = TerminationCriterion('end_time', initial_time + 0.01)
        integration_control = IntegrationControl(initial_time, termination_criterion, 0.001)
        time_integration_prob = om.Problem()
        time_integration_prob.model.add_subsystem(
            "test_comp", test_class(integration_control=integration_control)
        )
    
        time_integration_prob.model.nonlinear_solver = om.NewtonSolver(
            solve_subsystems=True
        )
        time_integration_prob.model.linear_solver = om.ScipyKrylov()
    
        runge_kutta_prob = om.Problem()
        runge_kutta_prob.model.add_subsystem(
            "rk_integrator",
            RungeKuttaIntegrator(
                time_stage_problem=time_integration_prob,
                butcher_tableau=butcher_tableau,
                integration_control=integration_control,
                time_integration_quantities=["x"],
                time_independent_input_quantities=["b"],
                checkpointing_type=checkpointing_implementation,
                error_controller=test_controller,
                error_estimator_type=test_estimator,
                adaptive_time_stepping=True,
            ),
            promotes=["*"],
        )
    
        runge_kutta_prob.setup()
        runge_kutta_prob["b"] = parameter
        runge_kutta_prob.run_model()
        if checkpointing_implementation == NoCheckpointer:
            with pytest.raises(NotImplementedError):
                runge_kutta_prob.check_partials(excludes=["Jfd","fd","Jfor-Jfd","Jrev-Jfd"])
        else:
            data = runge_kutta_prob.check_partials()
>           assert_check_partials(data)

test_component_test_adaptive.py:517: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = {'rk_integrator': {('x_final', 'b'): {'J_fd': array([[0.0100827]]), 'J_fwd': array([[0.01008265]]), 'J_rev': array([[0...), 'abs error': ErrorTuple(forward=1.8919155131413845e-10, reverse=1.8919155131413845e-10, forward_reverse=0.0), ...}}}
atol = 1e-06, rtol = 1e-06

    def assert_check_partials(data, atol=1e-6, rtol=1e-6):
        """
        Raise assertion if any entry from the return from check_partials is above a tolerance.
    
        Parameters
        ----------
        data : dict of dicts of dicts
                First key:
                    is the component name;
                Second key:
                    is the (output, input) tuple of strings;
                Third key:
                    is one of ['rel error', 'abs error', 'magnitude', 'J_fd', 'J_fwd', 'J_rev'];
    
                For 'rel error', 'abs error', 'magnitude' the value is: A tuple containing norms for
                    forward - fd, adjoint - fd, forward - adjoint.
                For 'J_fd', 'J_fwd', 'J_rev' the value is: A numpy array representing the computed
                    Jacobian for the three different methods of computation.
        atol : float
            absolute error. Default is 1e-6.
        rtol : float
            relative error. Default is 1e-6.
        """
        error_string = ''
        absrel_header = 'abs/rel'
        wrt_header = '< output > wrt < variable >'
        norm_value_header = 'norm value'
        len_absrel_width = len(absrel_header)
        norm_types = ['fwd-fd', 'rev-fd', 'fd-rev']
        len_norm_type_width = max(len(s) for s in norm_types)
    
        for comp in data:
            len_wrt_width = len(wrt_header)
            len_norm_width = len(norm_value_header)
            bad_derivs = []
    
            # Find all derivatives whose errors exceed tolerance.
            # Also, size the output to precompute column extents.
            for (var, wrt) in data[comp]:
                pair_data = data[comp][var, wrt]
                for error_type, tolerance in [('abs error', atol), ('rel error', rtol), ]:
                    actual = pair_data[error_type]
                    for error_val, mode in zip(actual, norm_types):
                        in_error = False
    
                        if error_val is None:
                            # Reverse derivatives only computed on matrix free comps.
                            continue
    
                        if not np.isnan(error_val):
                            if not np.allclose(error_val, 0.0, atol=tolerance):
    
                                if error_type == 'rel error' and mode == 'fwd-fd' and \
                                   np.allclose(pair_data['J_fwd'], 0.0, atol=atol) and \
                                   np.allclose(pair_data['J_fd'], 0.0, atol=atol):
                                    # Special case: both fd and fwd are really tiny, so we want to
                                    # ignore the rather large relative errors.
                                    in_error = False
                                else:
                                    # This is a bona-fide error.
                                    in_error = True
    
                        elif error_type == 'abs error' and mode == 'fwd-fd':
                            # Either analytic or approximated derivatives contain a NaN.
                            in_error = True
    
                        if in_error:
                            wrt_string = '{0} wrt {1}'.format(var, wrt)
                            norm_string = '{}'.format(error_val)
                            bad_derivs.append((wrt_string, norm_string, error_type, mode))
                            len_wrt_width = max(len_wrt_width, len(wrt_string))
                            len_norm_width = max(len_norm_width, len(norm_string))
    
            if bad_derivs:
                comp_error_string = ''
                for wrt_string, norm_string, error_type, mode in bad_derivs:
                    err_msg = '{0} | {1} | {2} | {3}'.format(
                        pad_name(wrt_string, len_wrt_width),
                        pad_name(error_type.split()[0], len_absrel_width),
                        pad_name(mode, len_norm_type_width),
                        pad_name(norm_string, len_norm_width)) + '\n'
                    comp_error_string += err_msg
    
                name_header = 'Component: {}\n'.format(comp)
                len_name_header = len(name_header)
                header = len_name_header * '-' + '\n'
                header += name_header
                header += len_name_header * '-' + '\n'
                header += '{0} | {1} | {2} | {3}'.format(
                    pad_name(wrt_header, len_wrt_width),
                    pad_name(absrel_header, len_absrel_width),
                    pad_name('norm', len_norm_type_width),
                    pad_name(norm_value_header, len_norm_width),
                ) + '\n'
                header += '{0} | {1} | {2} | {3}'.format(
                    len_wrt_width * '-',
                    len_absrel_width * '-',
                    len_norm_type_width * '-',
                    len_norm_width * '-',
                ) + '\n'
                comp_error_string = header + comp_error_string
                error_string += comp_error_string
    
        # if error string then raise error with that string
        if error_string:
            header_line1 = 'Assert Check Partials failed for the following Components'
            header_line2 = 'with absolute tolerance = {} and relative tolerance = {}'.format(atol, rtol)
            header_width = max(len(header_line1), len(header_line2))
            header = '\n' + header_width * '=' + '\n'
            header += header_line1 + '\n'
            header += header_line2 + '\n'
            header += header_width * '=' + '\n'
            error_string = header + error_string
>           raise ValueError(error_string)
E           ValueError: 
E           ==============================================================
E           Assert Check Partials failed for the following Components
E           with absolute tolerance = 1e-06 and relative tolerance = 1e-06
E           ==============================================================
E           -------------------------
E           Component: rk_integrator
E           -------------------------
E           < output > wrt < variable > | abs/rel | norm   | norm value            
E           --------------------------- | ------- | ------ | ----------------------
E           x_final wrt b               | rel     | fwd-fd | 4.646018538981447e-06 
E           x_final wrt b               | rel     | rev-fd | 4.6460185391534964e-06

/home/shuv_im/.spack/rev.23.05/install/linux-rocky8-zen2/gcc-10.4.0/py-openmdao-3.9.1-dlr.6-w57zdo/lib/python3.9/site-packages/openmdao/utils/assert_utils.py:225: ValueError
----------------------------- Captured stdout call -----------------------------


Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting fwd-mode jacvec product


Resetting error estimator.


Starting step 1 of fwd-mode jacvec product.
Time = 0.0, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 1.
Starting stage 2 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 1.
Starting stage 3 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 1.
Starting stage 4 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 1.

Finished step 1 of fwd-mode jacvec product.


Starting step 2 of fwd-mode jacvec product.
Time = 0.001, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 2.
Starting stage 2 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 2.
Starting stage 3 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 2.
Starting stage 4 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 2.

Finished step 2 of fwd-mode jacvec product.


Starting step 3 of fwd-mode jacvec product.
Time = 0.0025891915007072277, dTime = 0.0015891915007072274.

Starting stage 1 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 3.
Starting stage 2 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 3.
Starting stage 3 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 3.
Starting stage 4 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 3.

Finished step 3 of fwd-mode jacvec product.


Starting step 4 of fwd-mode jacvec product.
Time = 0.009388759038567939, dTime = 0.006799567537860711.

Starting stage 1 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 4.
Starting stage 2 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 4.
Starting stage 3 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 4.
Starting stage 4 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 4.

Finished step 4 of fwd-mode jacvec product.



Finished fwd-mode jacvec product




Starting fwd-mode jacvec product


Resetting error estimator.


Starting step 1 of fwd-mode jacvec product.
Time = 0.0, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 1.
Starting stage 2 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 1.
Starting stage 3 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 1.
Starting stage 4 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 1.

Finished step 1 of fwd-mode jacvec product.


Starting step 2 of fwd-mode jacvec product.
Time = 0.001, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 2.
Starting stage 2 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 2.
Starting stage 3 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 2.
Starting stage 4 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 2.

Finished step 2 of fwd-mode jacvec product.


Starting step 3 of fwd-mode jacvec product.
Time = 0.0025891915007072277, dTime = 0.0015891915007072274.

Starting stage 1 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 3.
Starting stage 2 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 3.
Starting stage 3 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 3.
Starting stage 4 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 3.

Finished step 3 of fwd-mode jacvec product.


Starting step 4 of fwd-mode jacvec product.
Time = 0.009388759038567939, dTime = 0.006799567537860711.

Starting stage 1 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 4.
Starting stage 2 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 4.
Starting stage 3 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 4.
Starting stage 4 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 4.

Finished step 4 of fwd-mode jacvec product.



Finished fwd-mode jacvec product




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting rev-mode jacvec product



Starting step 4 of rev-mode jacvec product.
Time = 0.009388759038567939, dTime = 0.0006112409614320614.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 3 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Finished stage 3 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 4 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.
Finished stage 4 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 4 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 4 of the rev iteration of reve-mode jvp in
step 4.
Starting stage 3 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 3 of the rev iteration of reve-mode jvp in
step 4.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 4.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 4.

Finishing step 4 of rev-mode jacvec product.


Starting step 3 of rev-mode jacvec product.
Time = 0.0025891915007072277, dTime = 0.006799567537860711.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 3 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Finished stage 3 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 4 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.
Finished stage 4 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 4 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 4 of the rev iteration of reve-mode jvp in
step 3.
Starting stage 3 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 3 of the rev iteration of reve-mode jvp in
step 3.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 3.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 3.

Finishing step 3 of rev-mode jacvec product.


Starting step 2 of rev-mode jacvec product.
Time = 0.001, dTime = 0.0015891915007072274.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 3 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Finished stage 3 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 4 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.
Finished stage 4 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 4 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 4 of the rev iteration of reve-mode jvp in
step 2.
Starting stage 3 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 3 of the rev iteration of reve-mode jvp in
step 2.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 2.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 2.

Finishing step 2 of rev-mode jacvec product.


Starting step 1 of rev-mode jacvec product.
Time = 0.0, dTime = 0.001.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 3 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Finished stage 3 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 4 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.
Finished stage 4 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 4 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 4 of the rev iteration of reve-mode jvp in
step 1.
Starting stage 3 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 3 of the rev iteration of reve-mode jvp in
step 1.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 1.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 1.

Finishing step 1 of rev-mode jacvec product.



Finished rev-mode jacvec product




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.

Finishing step 4 of compute.



Finishing compute


-----------------------------------------------
Component: RungeKuttaIntegrator 'rk_integrator'
-----------------------------------------------
  rk_integrator: 'x_final' wrt 'b'
     Forward Magnitude: 1.008265e-02
     Reverse Magnitude: 1.008265e-02
          Fd Magnitude: 1.008270e-02 (fd:forward)
    Absolute Error (Jfor - Jfd) : 4.684442e-08
    Absolute Error (Jrev - Jfd) : 4.684442e-08
    Absolute Error (Jfor - Jrev): 1.734723e-18

    Relative Error (Jfor - Jfd) / Jfd : 4.646019e-06 *
    Relative Error (Jrev - Jfd) / Jfd : 4.646019e-06 *
    Relative Error (Jfor - Jrev) / Jfd: 1.720495e-16

    Raw Forward Derivative (Jfor)
[[0.01008265]]

    Raw Reverse Derivative (Jrev)
[[0.01008265]]

    Raw FD Derivative (Jfd)
[[0.0100827]]

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  rk_integrator: 'x_final' wrt 'x_initial'
     Forward Magnitude: 1.010050e+00
     Reverse Magnitude: 1.010050e+00
          Fd Magnitude: 1.010050e+00 (fd:forward)
    Absolute Error (Jfor - Jfd) : 1.891916e-10
    Absolute Error (Jrev - Jfd) : 1.891916e-10
    Absolute Error (Jfor - Jrev): 0.000000e+00

    Relative Error (Jfor - Jfd) / Jfd : 1.873091e-10
    Relative Error (Jrev - Jfd) / Jfd : 1.873091e-10
    Relative Error (Jfor - Jrev) / Jfd: 0.000000e+00

    Raw Forward Derivative (Jfor)
[[1.01005017]]

    Raw Reverse Derivative (Jrev)
[[1.01005017]]

    Raw FD Derivative (Jfd)
[[1.01005017]]

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
_ test_time_integration_with_parameter_partials[PID-ImprovedErrorEstimator-AllCheckpointer-butcher_tableau3-1.0-TestComp1-1.0] _

test_class = <class 'tests.test_components.TestComp1'>, initial_time = 1.0
parameter = 1.0
butcher_tableau = <rkopenmdao.butcher_tableau.EmbeddedButcherTableau object at 0x15551f7d7fd0>
checkpointing_implementation = <class 'rkopenmdao.checkpoint_interface.all_checkpointer.AllCheckpointer'>
test_estimator = <class 'rkopenmdao.error_estimator.ImprovedErrorEstimator'>
test_controller = <function PID at 0x1555201d5550>

    @pytest.mark.rk
    @pytest.mark.rk_openmdao
    @pytest.mark.parametrize(
        "test_class, initial_time",
        (
            [TestComp1, 0.0],
            [TestComp1, 1.0],
        ),
    )
    @pytest.mark.parametrize("parameter", [1.0])
    @pytest.mark.parametrize(
        "butcher_tableau",
        [
            heun_euler,
            two_stage_dirk,
            three_stage_esdirk,
            four_stage_esdirk,
            five_stage_esdirk
        ]
    )
    @pytest.mark.parametrize(
        "checkpointing_implementation",
        [
            NoCheckpointer,
            AllCheckpointer,
        ],
    )
    @pytest.mark.parametrize(
        "test_estimator",
        [
            SimpleErrorEstimator,
            ImprovedErrorEstimator
        ]
    )
    @pytest.mark.parametrize(
        "test_controller",
        [
            Integral,
            H0_110,
            PID
        ]
    )
    def test_time_integration_with_parameter_partials(
        test_class, initial_time, parameter, butcher_tableau, checkpointing_implementation, test_estimator, test_controller
    ):
        """Tests the partials of the time integration of the different components."""
        termination_criterion = TerminationCriterion('end_time', initial_time + 0.01)
        integration_control = IntegrationControl(initial_time, termination_criterion, 0.001)
        time_integration_prob = om.Problem()
        time_integration_prob.model.add_subsystem(
            "test_comp", test_class(integration_control=integration_control)
        )
    
        time_integration_prob.model.nonlinear_solver = om.NewtonSolver(
            solve_subsystems=True
        )
        time_integration_prob.model.linear_solver = om.ScipyKrylov()
    
        runge_kutta_prob = om.Problem()
        runge_kutta_prob.model.add_subsystem(
            "rk_integrator",
            RungeKuttaIntegrator(
                time_stage_problem=time_integration_prob,
                butcher_tableau=butcher_tableau,
                integration_control=integration_control,
                time_integration_quantities=["x"],
                time_independent_input_quantities=["b"],
                checkpointing_type=checkpointing_implementation,
                error_controller=test_controller,
                error_estimator_type=test_estimator,
                adaptive_time_stepping=True,
            ),
            promotes=["*"],
        )
    
        runge_kutta_prob.setup()
        runge_kutta_prob["b"] = parameter
        runge_kutta_prob.run_model()
        if checkpointing_implementation == NoCheckpointer:
            with pytest.raises(NotImplementedError):
                runge_kutta_prob.check_partials(excludes=["Jfd","fd","Jfor-Jfd","Jrev-Jfd"])
        else:
            data = runge_kutta_prob.check_partials()
>           assert_check_partials(data)

test_component_test_adaptive.py:517: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = {'rk_integrator': {('x_final', 'b'): {'J_fd': array([[0.0100827]]), 'J_fwd': array([[0.01008265]]), 'J_rev': array([[0...rrorTuple(forward=1.8919177335874338e-10, reverse=1.891919954033483e-10, forward_reverse=2.220446049250313e-16), ...}}}
atol = 1e-06, rtol = 1e-06

    def assert_check_partials(data, atol=1e-6, rtol=1e-6):
        """
        Raise assertion if any entry from the return from check_partials is above a tolerance.
    
        Parameters
        ----------
        data : dict of dicts of dicts
                First key:
                    is the component name;
                Second key:
                    is the (output, input) tuple of strings;
                Third key:
                    is one of ['rel error', 'abs error', 'magnitude', 'J_fd', 'J_fwd', 'J_rev'];
    
                For 'rel error', 'abs error', 'magnitude' the value is: A tuple containing norms for
                    forward - fd, adjoint - fd, forward - adjoint.
                For 'J_fd', 'J_fwd', 'J_rev' the value is: A numpy array representing the computed
                    Jacobian for the three different methods of computation.
        atol : float
            absolute error. Default is 1e-6.
        rtol : float
            relative error. Default is 1e-6.
        """
        error_string = ''
        absrel_header = 'abs/rel'
        wrt_header = '< output > wrt < variable >'
        norm_value_header = 'norm value'
        len_absrel_width = len(absrel_header)
        norm_types = ['fwd-fd', 'rev-fd', 'fd-rev']
        len_norm_type_width = max(len(s) for s in norm_types)
    
        for comp in data:
            len_wrt_width = len(wrt_header)
            len_norm_width = len(norm_value_header)
            bad_derivs = []
    
            # Find all derivatives whose errors exceed tolerance.
            # Also, size the output to precompute column extents.
            for (var, wrt) in data[comp]:
                pair_data = data[comp][var, wrt]
                for error_type, tolerance in [('abs error', atol), ('rel error', rtol), ]:
                    actual = pair_data[error_type]
                    for error_val, mode in zip(actual, norm_types):
                        in_error = False
    
                        if error_val is None:
                            # Reverse derivatives only computed on matrix free comps.
                            continue
    
                        if not np.isnan(error_val):
                            if not np.allclose(error_val, 0.0, atol=tolerance):
    
                                if error_type == 'rel error' and mode == 'fwd-fd' and \
                                   np.allclose(pair_data['J_fwd'], 0.0, atol=atol) and \
                                   np.allclose(pair_data['J_fd'], 0.0, atol=atol):
                                    # Special case: both fd and fwd are really tiny, so we want to
                                    # ignore the rather large relative errors.
                                    in_error = False
                                else:
                                    # This is a bona-fide error.
                                    in_error = True
    
                        elif error_type == 'abs error' and mode == 'fwd-fd':
                            # Either analytic or approximated derivatives contain a NaN.
                            in_error = True
    
                        if in_error:
                            wrt_string = '{0} wrt {1}'.format(var, wrt)
                            norm_string = '{}'.format(error_val)
                            bad_derivs.append((wrt_string, norm_string, error_type, mode))
                            len_wrt_width = max(len_wrt_width, len(wrt_string))
                            len_norm_width = max(len_norm_width, len(norm_string))
    
            if bad_derivs:
                comp_error_string = ''
                for wrt_string, norm_string, error_type, mode in bad_derivs:
                    err_msg = '{0} | {1} | {2} | {3}'.format(
                        pad_name(wrt_string, len_wrt_width),
                        pad_name(error_type.split()[0], len_absrel_width),
                        pad_name(mode, len_norm_type_width),
                        pad_name(norm_string, len_norm_width)) + '\n'
                    comp_error_string += err_msg
    
                name_header = 'Component: {}\n'.format(comp)
                len_name_header = len(name_header)
                header = len_name_header * '-' + '\n'
                header += name_header
                header += len_name_header * '-' + '\n'
                header += '{0} | {1} | {2} | {3}'.format(
                    pad_name(wrt_header, len_wrt_width),
                    pad_name(absrel_header, len_absrel_width),
                    pad_name('norm', len_norm_type_width),
                    pad_name(norm_value_header, len_norm_width),
                ) + '\n'
                header += '{0} | {1} | {2} | {3}'.format(
                    len_wrt_width * '-',
                    len_absrel_width * '-',
                    len_norm_type_width * '-',
                    len_norm_width * '-',
                ) + '\n'
                comp_error_string = header + comp_error_string
                error_string += comp_error_string
    
        # if error string then raise error with that string
        if error_string:
            header_line1 = 'Assert Check Partials failed for the following Components'
            header_line2 = 'with absolute tolerance = {} and relative tolerance = {}'.format(atol, rtol)
            header_width = max(len(header_line1), len(header_line2))
            header = '\n' + header_width * '=' + '\n'
            header += header_line1 + '\n'
            header += header_line2 + '\n'
            header += header_width * '=' + '\n'
            error_string = header + error_string
>           raise ValueError(error_string)
E           ValueError: 
E           ==============================================================
E           Assert Check Partials failed for the following Components
E           with absolute tolerance = 1e-06 and relative tolerance = 1e-06
E           ==============================================================
E           -------------------------
E           Component: rk_integrator
E           -------------------------
E           < output > wrt < variable > | abs/rel | norm   | norm value           
E           --------------------------- | ------- | ------ | ---------------------
E           x_final wrt b               | rel     | fwd-fd | 4.646018516959113e-06
E           x_final wrt b               | rel     | rev-fd | 4.646018516959113e-06

/home/shuv_im/.spack/rev.23.05/install/linux-rocky8-zen2/gcc-10.4.0/py-openmdao-3.9.1-dlr.6-w57zdo/lib/python3.9/site-packages/openmdao/utils/assert_utils.py:225: ValueError
----------------------------- Captured stdout call -----------------------------


Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting fwd-mode jacvec product


Resetting error estimator.


Starting step 1 of fwd-mode jacvec product.
Time = 1.0, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 1.
Starting stage 2 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 1.
Starting stage 3 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 1.
Starting stage 4 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 1.

Finished step 1 of fwd-mode jacvec product.


Starting step 2 of fwd-mode jacvec product.
Time = 1.001, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 2.
Starting stage 2 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 2.
Starting stage 3 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 2.
Starting stage 4 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 2.

Finished step 2 of fwd-mode jacvec product.


Starting step 3 of fwd-mode jacvec product.
Time = 1.002589191500707, dTime = 0.0015891915007072274.

Starting stage 1 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 3.
Starting stage 2 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 3.
Starting stage 3 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 3.
Starting stage 4 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 3.

Finished step 3 of fwd-mode jacvec product.


Starting step 4 of fwd-mode jacvec product.
Time = 1.0093887590385677, dTime = 0.006799567537860711.

Starting stage 1 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 4.
Starting stage 2 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 4.
Starting stage 3 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 4.
Starting stage 4 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 4.

Finished step 4 of fwd-mode jacvec product.



Finished fwd-mode jacvec product




Starting fwd-mode jacvec product


Resetting error estimator.


Starting step 1 of fwd-mode jacvec product.
Time = 1.0, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 1.
Starting stage 2 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 1.
Starting stage 3 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 1.
Starting stage 4 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 1.

Finished step 1 of fwd-mode jacvec product.


Starting step 2 of fwd-mode jacvec product.
Time = 1.001, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 2.
Starting stage 2 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 2.
Starting stage 3 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 2.
Starting stage 4 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 2.

Finished step 2 of fwd-mode jacvec product.


Starting step 3 of fwd-mode jacvec product.
Time = 1.002589191500707, dTime = 0.0015891915007072274.

Starting stage 1 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 3.
Starting stage 2 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 3.
Starting stage 3 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 3.
Starting stage 4 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 3.

Finished step 3 of fwd-mode jacvec product.


Starting step 4 of fwd-mode jacvec product.
Time = 1.0093887590385677, dTime = 0.006799567537860711.

Starting stage 1 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 4.
Starting stage 2 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 4.
Starting stage 3 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 4.
Starting stage 4 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 4.

Finished step 4 of fwd-mode jacvec product.



Finished fwd-mode jacvec product




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting rev-mode jacvec product



Starting step 4 of rev-mode jacvec product.
Time = 1.0093887590385677, dTime = 0.00061124096143228.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 3 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Finished stage 3 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 4 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.
Finished stage 4 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 4 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 4 of the rev iteration of reve-mode jvp in
step 4.
Starting stage 3 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 3 of the rev iteration of reve-mode jvp in
step 4.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 4.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 4.

Finishing step 4 of rev-mode jacvec product.


Starting step 3 of rev-mode jacvec product.
Time = 1.002589191500707, dTime = 0.006799567537860711.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 3 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Finished stage 3 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 4 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.
Finished stage 4 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 4 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 4 of the rev iteration of reve-mode jvp in
step 3.
Starting stage 3 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 3 of the rev iteration of reve-mode jvp in
step 3.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 3.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 3.

Finishing step 3 of rev-mode jacvec product.


Starting step 2 of rev-mode jacvec product.
Time = 1.001, dTime = 0.0015891915007072274.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 3 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Finished stage 3 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 4 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.
Finished stage 4 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 4 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 4 of the rev iteration of reve-mode jvp in
step 2.
Starting stage 3 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 3 of the rev iteration of reve-mode jvp in
step 2.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 2.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 2.

Finishing step 2 of rev-mode jacvec product.


Starting step 1 of rev-mode jacvec product.
Time = 1.0, dTime = 0.001.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 3 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Finished stage 3 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 4 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.
Finished stage 4 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 4 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 4 of the rev iteration of reve-mode jvp in
step 1.
Starting stage 3 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 3 of the rev iteration of reve-mode jvp in
step 1.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 1.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 1.

Finishing step 1 of rev-mode jacvec product.



Finished rev-mode jacvec product




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.

Finishing step 4 of compute.



Finishing compute


-----------------------------------------------
Component: RungeKuttaIntegrator 'rk_integrator'
-----------------------------------------------
  rk_integrator: 'x_final' wrt 'b'
     Forward Magnitude: 1.008265e-02
     Reverse Magnitude: 1.008265e-02
          Fd Magnitude: 1.008270e-02 (fd:forward)
    Absolute Error (Jfor - Jfd) : 4.684442e-08
    Absolute Error (Jrev - Jfd) : 4.684442e-08
    Absolute Error (Jfor - Jrev): 0.000000e+00

    Relative Error (Jfor - Jfd) / Jfd : 4.646019e-06 *
    Relative Error (Jrev - Jfd) / Jfd : 4.646019e-06 *
    Relative Error (Jfor - Jrev) / Jfd: 0.000000e+00

    Raw Forward Derivative (Jfor)
[[0.01008265]]

    Raw Reverse Derivative (Jrev)
[[0.01008265]]

    Raw FD Derivative (Jfd)
[[0.0100827]]

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  rk_integrator: 'x_final' wrt 'x_initial'
     Forward Magnitude: 1.010050e+00
     Reverse Magnitude: 1.010050e+00
          Fd Magnitude: 1.010050e+00 (fd:forward)
    Absolute Error (Jfor - Jfd) : 1.891918e-10
    Absolute Error (Jrev - Jfd) : 1.891920e-10
    Absolute Error (Jfor - Jrev): 2.220446e-16

    Relative Error (Jfor - Jfd) / Jfd : 1.873093e-10
    Relative Error (Jrev - Jfd) / Jfd : 1.873095e-10
    Relative Error (Jfor - Jrev) / Jfd: 2.198352e-16

    Raw Forward Derivative (Jfor)
[[1.01005017]]

    Raw Reverse Derivative (Jrev)
[[1.01005017]]

    Raw FD Derivative (Jfd)
[[1.01005017]]

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
_ test_time_integration_with_parameter_partials[PID-ImprovedErrorEstimator-AllCheckpointer-butcher_tableau4-1.0-TestComp1-0.0] _

test_class = <class 'tests.test_components.TestComp1'>, initial_time = 0.0
parameter = 1.0
butcher_tableau = <rkopenmdao.butcher_tableau.EmbeddedButcherTableau object at 0x15551f7d7d30>
checkpointing_implementation = <class 'rkopenmdao.checkpoint_interface.all_checkpointer.AllCheckpointer'>
test_estimator = <class 'rkopenmdao.error_estimator.ImprovedErrorEstimator'>
test_controller = <function PID at 0x1555201d5550>

    @pytest.mark.rk
    @pytest.mark.rk_openmdao
    @pytest.mark.parametrize(
        "test_class, initial_time",
        (
            [TestComp1, 0.0],
            [TestComp1, 1.0],
        ),
    )
    @pytest.mark.parametrize("parameter", [1.0])
    @pytest.mark.parametrize(
        "butcher_tableau",
        [
            heun_euler,
            two_stage_dirk,
            three_stage_esdirk,
            four_stage_esdirk,
            five_stage_esdirk
        ]
    )
    @pytest.mark.parametrize(
        "checkpointing_implementation",
        [
            NoCheckpointer,
            AllCheckpointer,
        ],
    )
    @pytest.mark.parametrize(
        "test_estimator",
        [
            SimpleErrorEstimator,
            ImprovedErrorEstimator
        ]
    )
    @pytest.mark.parametrize(
        "test_controller",
        [
            Integral,
            H0_110,
            PID
        ]
    )
    def test_time_integration_with_parameter_partials(
        test_class, initial_time, parameter, butcher_tableau, checkpointing_implementation, test_estimator, test_controller
    ):
        """Tests the partials of the time integration of the different components."""
        termination_criterion = TerminationCriterion('end_time', initial_time + 0.01)
        integration_control = IntegrationControl(initial_time, termination_criterion, 0.001)
        time_integration_prob = om.Problem()
        time_integration_prob.model.add_subsystem(
            "test_comp", test_class(integration_control=integration_control)
        )
    
        time_integration_prob.model.nonlinear_solver = om.NewtonSolver(
            solve_subsystems=True
        )
        time_integration_prob.model.linear_solver = om.ScipyKrylov()
    
        runge_kutta_prob = om.Problem()
        runge_kutta_prob.model.add_subsystem(
            "rk_integrator",
            RungeKuttaIntegrator(
                time_stage_problem=time_integration_prob,
                butcher_tableau=butcher_tableau,
                integration_control=integration_control,
                time_integration_quantities=["x"],
                time_independent_input_quantities=["b"],
                checkpointing_type=checkpointing_implementation,
                error_controller=test_controller,
                error_estimator_type=test_estimator,
                adaptive_time_stepping=True,
            ),
            promotes=["*"],
        )
    
        runge_kutta_prob.setup()
        runge_kutta_prob["b"] = parameter
        runge_kutta_prob.run_model()
        if checkpointing_implementation == NoCheckpointer:
            with pytest.raises(NotImplementedError):
                runge_kutta_prob.check_partials(excludes=["Jfd","fd","Jfor-Jfd","Jrev-Jfd"])
        else:
            data = runge_kutta_prob.check_partials()
>           assert_check_partials(data)

test_component_test_adaptive.py:517: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = {'rk_integrator': {('x_final', 'b'): {'J_fd': array([[0.01008738]]), 'J_fwd': array([[0.01008762]]), 'J_rev': array([[...rorTuple(forward=2.3496982137771738e-11, reverse=2.3496760093166813e-11, forward_reverse=2.220446049250313e-16), ...}}}
atol = 1e-06, rtol = 1e-06

    def assert_check_partials(data, atol=1e-6, rtol=1e-6):
        """
        Raise assertion if any entry from the return from check_partials is above a tolerance.
    
        Parameters
        ----------
        data : dict of dicts of dicts
                First key:
                    is the component name;
                Second key:
                    is the (output, input) tuple of strings;
                Third key:
                    is one of ['rel error', 'abs error', 'magnitude', 'J_fd', 'J_fwd', 'J_rev'];
    
                For 'rel error', 'abs error', 'magnitude' the value is: A tuple containing norms for
                    forward - fd, adjoint - fd, forward - adjoint.
                For 'J_fd', 'J_fwd', 'J_rev' the value is: A numpy array representing the computed
                    Jacobian for the three different methods of computation.
        atol : float
            absolute error. Default is 1e-6.
        rtol : float
            relative error. Default is 1e-6.
        """
        error_string = ''
        absrel_header = 'abs/rel'
        wrt_header = '< output > wrt < variable >'
        norm_value_header = 'norm value'
        len_absrel_width = len(absrel_header)
        norm_types = ['fwd-fd', 'rev-fd', 'fd-rev']
        len_norm_type_width = max(len(s) for s in norm_types)
    
        for comp in data:
            len_wrt_width = len(wrt_header)
            len_norm_width = len(norm_value_header)
            bad_derivs = []
    
            # Find all derivatives whose errors exceed tolerance.
            # Also, size the output to precompute column extents.
            for (var, wrt) in data[comp]:
                pair_data = data[comp][var, wrt]
                for error_type, tolerance in [('abs error', atol), ('rel error', rtol), ]:
                    actual = pair_data[error_type]
                    for error_val, mode in zip(actual, norm_types):
                        in_error = False
    
                        if error_val is None:
                            # Reverse derivatives only computed on matrix free comps.
                            continue
    
                        if not np.isnan(error_val):
                            if not np.allclose(error_val, 0.0, atol=tolerance):
    
                                if error_type == 'rel error' and mode == 'fwd-fd' and \
                                   np.allclose(pair_data['J_fwd'], 0.0, atol=atol) and \
                                   np.allclose(pair_data['J_fd'], 0.0, atol=atol):
                                    # Special case: both fd and fwd are really tiny, so we want to
                                    # ignore the rather large relative errors.
                                    in_error = False
                                else:
                                    # This is a bona-fide error.
                                    in_error = True
    
                        elif error_type == 'abs error' and mode == 'fwd-fd':
                            # Either analytic or approximated derivatives contain a NaN.
                            in_error = True
    
                        if in_error:
                            wrt_string = '{0} wrt {1}'.format(var, wrt)
                            norm_string = '{}'.format(error_val)
                            bad_derivs.append((wrt_string, norm_string, error_type, mode))
                            len_wrt_width = max(len_wrt_width, len(wrt_string))
                            len_norm_width = max(len_norm_width, len(norm_string))
    
            if bad_derivs:
                comp_error_string = ''
                for wrt_string, norm_string, error_type, mode in bad_derivs:
                    err_msg = '{0} | {1} | {2} | {3}'.format(
                        pad_name(wrt_string, len_wrt_width),
                        pad_name(error_type.split()[0], len_absrel_width),
                        pad_name(mode, len_norm_type_width),
                        pad_name(norm_string, len_norm_width)) + '\n'
                    comp_error_string += err_msg
    
                name_header = 'Component: {}\n'.format(comp)
                len_name_header = len(name_header)
                header = len_name_header * '-' + '\n'
                header += name_header
                header += len_name_header * '-' + '\n'
                header += '{0} | {1} | {2} | {3}'.format(
                    pad_name(wrt_header, len_wrt_width),
                    pad_name(absrel_header, len_absrel_width),
                    pad_name('norm', len_norm_type_width),
                    pad_name(norm_value_header, len_norm_width),
                ) + '\n'
                header += '{0} | {1} | {2} | {3}'.format(
                    len_wrt_width * '-',
                    len_absrel_width * '-',
                    len_norm_type_width * '-',
                    len_norm_width * '-',
                ) + '\n'
                comp_error_string = header + comp_error_string
                error_string += comp_error_string
    
        # if error string then raise error with that string
        if error_string:
            header_line1 = 'Assert Check Partials failed for the following Components'
            header_line2 = 'with absolute tolerance = {} and relative tolerance = {}'.format(atol, rtol)
            header_width = max(len(header_line1), len(header_line2))
            header = '\n' + header_width * '=' + '\n'
            header += header_line1 + '\n'
            header += header_line2 + '\n'
            header += header_width * '=' + '\n'
            error_string = header + error_string
>           raise ValueError(error_string)
E           ValueError: 
E           ==============================================================
E           Assert Check Partials failed for the following Components
E           with absolute tolerance = 1e-06 and relative tolerance = 1e-06
E           ==============================================================
E           -------------------------
E           Component: rk_integrator
E           -------------------------
E           < output > wrt < variable > | abs/rel | norm   | norm value            
E           --------------------------- | ------- | ------ | ----------------------
E           x_final wrt b               | rel     | fwd-fd | 2.3891644348683383e-05
E           x_final wrt b               | rel     | rev-fd | 2.3891644349371262e-05

/home/shuv_im/.spack/rev.23.05/install/linux-rocky8-zen2/gcc-10.4.0/py-openmdao-3.9.1-dlr.6-w57zdo/lib/python3.9/site-packages/openmdao/utils/assert_utils.py:225: ValueError
----------------------------- Captured stdout call -----------------------------


Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.
Starting stage 5 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.
Starting stage 5 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.
Starting stage 5 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.
Starting stage 5 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.
Starting stage 5 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.
Starting stage 5 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.
Starting stage 5 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.
Starting stage 5 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting fwd-mode jacvec product


Resetting error estimator.


Starting step 1 of fwd-mode jacvec product.
Time = 0.0, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 1.
Starting stage 2 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 1.
Starting stage 3 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 1.
Starting stage 4 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 1.
Starting stage 5 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 5 of fwd-mode jacvec product in step 1.

Finished step 1 of fwd-mode jacvec product.


Starting step 2 of fwd-mode jacvec product.
Time = 0.001, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 2.
Starting stage 2 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 2.
Starting stage 3 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 2.
Starting stage 4 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 2.
Starting stage 5 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 5 of fwd-mode jacvec product in step 2.

Finished step 2 of fwd-mode jacvec product.


Starting step 3 of fwd-mode jacvec product.
Time = 0.002268037532405876, dTime = 0.0012680375324058762.

Starting stage 1 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 3.
Starting stage 2 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 3.
Starting stage 3 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 3.
Starting stage 4 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 3.
Starting stage 5 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 5 of fwd-mode jacvec product in step 3.

Finished step 3 of fwd-mode jacvec product.


Starting step 4 of fwd-mode jacvec product.
Time = 0.005082763210056034, dTime = 0.002814725677650158.

Starting stage 1 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 4.
Starting stage 2 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 4.
Starting stage 3 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 4.
Starting stage 4 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 4.
Starting stage 5 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 5 of fwd-mode jacvec product in step 4.

Finished step 4 of fwd-mode jacvec product.



Finished fwd-mode jacvec product




Starting fwd-mode jacvec product


Resetting error estimator.


Starting step 1 of fwd-mode jacvec product.
Time = 0.0, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 1.
Starting stage 2 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 1.
Starting stage 3 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 1.
Starting stage 4 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 1.
Starting stage 5 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 5 of fwd-mode jacvec product in step 1.

Finished step 1 of fwd-mode jacvec product.


Starting step 2 of fwd-mode jacvec product.
Time = 0.001, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 2.
Starting stage 2 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 2.
Starting stage 3 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 2.
Starting stage 4 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 2.
Starting stage 5 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 5 of fwd-mode jacvec product in step 2.

Finished step 2 of fwd-mode jacvec product.


Starting step 3 of fwd-mode jacvec product.
Time = 0.002268037532405876, dTime = 0.0012680375324058762.

Starting stage 1 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 3.
Starting stage 2 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 3.
Starting stage 3 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 3.
Starting stage 4 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 3.
Starting stage 5 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 5 of fwd-mode jacvec product in step 3.

Finished step 3 of fwd-mode jacvec product.


Starting step 4 of fwd-mode jacvec product.
Time = 0.005082763210056034, dTime = 0.002814725677650158.

Starting stage 1 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 4.
Starting stage 2 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 4.
Starting stage 3 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 4.
Starting stage 4 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 4.
Starting stage 5 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 5 of fwd-mode jacvec product in step 4.

Finished step 4 of fwd-mode jacvec product.



Finished fwd-mode jacvec product




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.
Starting stage 5 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.
Starting stage 5 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.
Starting stage 5 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.
Starting stage 5 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting rev-mode jacvec product



Starting step 4 of rev-mode jacvec product.
Time = 0.005082763210056034, dTime = 0.004917236789943966.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 3 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Finished stage 3 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 4 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.
Finished stage 4 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 5 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 5 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 4.
Finished stage 5 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 5 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 5 of the rev iteration of reve-mode jvp in
step 4.
Starting stage 4 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 4 of the rev iteration of reve-mode jvp in
step 4.
Starting stage 3 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 3 of the rev iteration of reve-mode jvp in
step 4.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 4.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 4.

Finishing step 4 of rev-mode jacvec product.


Starting step 3 of rev-mode jacvec product.
Time = 0.002268037532405876, dTime = 0.002814725677650158.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 3 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Finished stage 3 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 4 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.
Finished stage 4 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 5 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 5 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 3.
Finished stage 5 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 5 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 5 of the rev iteration of reve-mode jvp in
step 3.
Starting stage 4 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 4 of the rev iteration of reve-mode jvp in
step 3.
Starting stage 3 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 3 of the rev iteration of reve-mode jvp in
step 3.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 3.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 3.

Finishing step 3 of rev-mode jacvec product.


Starting step 2 of rev-mode jacvec product.
Time = 0.001, dTime = 0.0012680375324058762.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 3 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Finished stage 3 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 4 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.
Finished stage 4 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 5 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 5 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 2.
Finished stage 5 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 5 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 5 of the rev iteration of reve-mode jvp in
step 2.
Starting stage 4 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 4 of the rev iteration of reve-mode jvp in
step 2.
Starting stage 3 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 3 of the rev iteration of reve-mode jvp in
step 2.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 2.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 2.

Finishing step 2 of rev-mode jacvec product.


Starting step 1 of rev-mode jacvec product.
Time = 0.0, dTime = 0.001.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 3 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Finished stage 3 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 4 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.
Finished stage 4 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 5 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 5 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 1.
Finished stage 5 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 5 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 5 of the rev iteration of reve-mode jvp in
step 1.
Starting stage 4 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 4 of the rev iteration of reve-mode jvp in
step 1.
Starting stage 3 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 3 of the rev iteration of reve-mode jvp in
step 1.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 1.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 1.

Finishing step 1 of rev-mode jacvec product.



Finished rev-mode jacvec product




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.
Starting stage 5 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.
Starting stage 5 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.
Starting stage 5 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.
Starting stage 5 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.
Starting stage 5 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.
Starting stage 5 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.
Starting stage 5 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.
Starting stage 5 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.
Starting stage 5 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.
Starting stage 5 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.
Starting stage 5 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.
Starting stage 5 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 4.

Finishing step 4 of compute.



Finishing compute


-----------------------------------------------
Component: RungeKuttaIntegrator 'rk_integrator'
-----------------------------------------------
  rk_integrator: 'x_final' wrt 'b'
     Forward Magnitude: 1.008762e-02
     Reverse Magnitude: 1.008762e-02
          Fd Magnitude: 1.008738e-02 (fd:forward)
    Absolute Error (Jfor - Jfd) : 2.410041e-07
    Absolute Error (Jrev - Jfd) : 2.410041e-07
    Absolute Error (Jfor - Jrev): 6.938894e-18

    Relative Error (Jfor - Jfd) / Jfd : 2.389164e-05 *
    Relative Error (Jrev - Jfd) / Jfd : 2.389164e-05 *
    Relative Error (Jfor - Jrev) / Jfd: 6.878787e-16

    Raw Forward Derivative (Jfor)
[[0.01008762]]

    Raw Reverse Derivative (Jrev)
[[0.01008762]]

    Raw FD Derivative (Jfd)
[[0.01008738]]

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  rk_integrator: 'x_final' wrt 'x_initial'
     Forward Magnitude: 1.010050e+00
     Reverse Magnitude: 1.010050e+00
          Fd Magnitude: 1.010050e+00 (fd:forward)
    Absolute Error (Jfor - Jfd) : 2.349698e-11
    Absolute Error (Jrev - Jfd) : 2.349676e-11
    Absolute Error (Jfor - Jrev): 2.220446e-16

    Relative Error (Jfor - Jfd) / Jfd : 2.326318e-11
    Relative Error (Jrev - Jfd) / Jfd : 2.326296e-11
    Relative Error (Jfor - Jrev) / Jfd: 2.198352e-16

    Raw Forward Derivative (Jfor)
[[1.01005017]]

    Raw Reverse Derivative (Jrev)
[[1.01005017]]

    Raw FD Derivative (Jfd)
[[1.01005017]]

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
_ test_time_integration_with_parameter_partials[PID-ImprovedErrorEstimator-AllCheckpointer-butcher_tableau4-1.0-TestComp1-1.0] _

test_class = <class 'tests.test_components.TestComp1'>, initial_time = 1.0
parameter = 1.0
butcher_tableau = <rkopenmdao.butcher_tableau.EmbeddedButcherTableau object at 0x15551f7d7d30>
checkpointing_implementation = <class 'rkopenmdao.checkpoint_interface.all_checkpointer.AllCheckpointer'>
test_estimator = <class 'rkopenmdao.error_estimator.ImprovedErrorEstimator'>
test_controller = <function PID at 0x1555201d5550>

    @pytest.mark.rk
    @pytest.mark.rk_openmdao
    @pytest.mark.parametrize(
        "test_class, initial_time",
        (
            [TestComp1, 0.0],
            [TestComp1, 1.0],
        ),
    )
    @pytest.mark.parametrize("parameter", [1.0])
    @pytest.mark.parametrize(
        "butcher_tableau",
        [
            heun_euler,
            two_stage_dirk,
            three_stage_esdirk,
            four_stage_esdirk,
            five_stage_esdirk
        ]
    )
    @pytest.mark.parametrize(
        "checkpointing_implementation",
        [
            NoCheckpointer,
            AllCheckpointer,
        ],
    )
    @pytest.mark.parametrize(
        "test_estimator",
        [
            SimpleErrorEstimator,
            ImprovedErrorEstimator
        ]
    )
    @pytest.mark.parametrize(
        "test_controller",
        [
            Integral,
            H0_110,
            PID
        ]
    )
    def test_time_integration_with_parameter_partials(
        test_class, initial_time, parameter, butcher_tableau, checkpointing_implementation, test_estimator, test_controller
    ):
        """Tests the partials of the time integration of the different components."""
        termination_criterion = TerminationCriterion('end_time', initial_time + 0.01)
        integration_control = IntegrationControl(initial_time, termination_criterion, 0.001)
        time_integration_prob = om.Problem()
        time_integration_prob.model.add_subsystem(
            "test_comp", test_class(integration_control=integration_control)
        )
    
        time_integration_prob.model.nonlinear_solver = om.NewtonSolver(
            solve_subsystems=True
        )
        time_integration_prob.model.linear_solver = om.ScipyKrylov()
    
        runge_kutta_prob = om.Problem()
        runge_kutta_prob.model.add_subsystem(
            "rk_integrator",
            RungeKuttaIntegrator(
                time_stage_problem=time_integration_prob,
                butcher_tableau=butcher_tableau,
                integration_control=integration_control,
                time_integration_quantities=["x"],
                time_independent_input_quantities=["b"],
                checkpointing_type=checkpointing_implementation,
                error_controller=test_controller,
                error_estimator_type=test_estimator,
                adaptive_time_stepping=True,
            ),
            promotes=["*"],
        )
    
        runge_kutta_prob.setup()
        runge_kutta_prob["b"] = parameter
        runge_kutta_prob.run_model()
        if checkpointing_implementation == NoCheckpointer:
            with pytest.raises(NotImplementedError):
                runge_kutta_prob.check_partials(excludes=["Jfd","fd","Jfor-Jfd","Jrev-Jfd"])
        else:
            data = runge_kutta_prob.check_partials()
>           assert_check_partials(data)

test_component_test_adaptive.py:517: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = {'rk_integrator': {('x_final', 'b'): {'J_fd': array([[0.01008738]]), 'J_fwd': array([[0.01008762]]), 'J_rev': array([[...rorTuple(forward=2.3496982137771738e-11, reverse=2.3496760093166813e-11, forward_reverse=2.220446049250313e-16), ...}}}
atol = 1e-06, rtol = 1e-06

    def assert_check_partials(data, atol=1e-6, rtol=1e-6):
        """
        Raise assertion if any entry from the return from check_partials is above a tolerance.
    
        Parameters
        ----------
        data : dict of dicts of dicts
                First key:
                    is the component name;
                Second key:
                    is the (output, input) tuple of strings;
                Third key:
                    is one of ['rel error', 'abs error', 'magnitude', 'J_fd', 'J_fwd', 'J_rev'];
    
                For 'rel error', 'abs error', 'magnitude' the value is: A tuple containing norms for
                    forward - fd, adjoint - fd, forward - adjoint.
                For 'J_fd', 'J_fwd', 'J_rev' the value is: A numpy array representing the computed
                    Jacobian for the three different methods of computation.
        atol : float
            absolute error. Default is 1e-6.
        rtol : float
            relative error. Default is 1e-6.
        """
        error_string = ''
        absrel_header = 'abs/rel'
        wrt_header = '< output > wrt < variable >'
        norm_value_header = 'norm value'
        len_absrel_width = len(absrel_header)
        norm_types = ['fwd-fd', 'rev-fd', 'fd-rev']
        len_norm_type_width = max(len(s) for s in norm_types)
    
        for comp in data:
            len_wrt_width = len(wrt_header)
            len_norm_width = len(norm_value_header)
            bad_derivs = []
    
            # Find all derivatives whose errors exceed tolerance.
            # Also, size the output to precompute column extents.
            for (var, wrt) in data[comp]:
                pair_data = data[comp][var, wrt]
                for error_type, tolerance in [('abs error', atol), ('rel error', rtol), ]:
                    actual = pair_data[error_type]
                    for error_val, mode in zip(actual, norm_types):
                        in_error = False
    
                        if error_val is None:
                            # Reverse derivatives only computed on matrix free comps.
                            continue
    
                        if not np.isnan(error_val):
                            if not np.allclose(error_val, 0.0, atol=tolerance):
    
                                if error_type == 'rel error' and mode == 'fwd-fd' and \
                                   np.allclose(pair_data['J_fwd'], 0.0, atol=atol) and \
                                   np.allclose(pair_data['J_fd'], 0.0, atol=atol):
                                    # Special case: both fd and fwd are really tiny, so we want to
                                    # ignore the rather large relative errors.
                                    in_error = False
                                else:
                                    # This is a bona-fide error.
                                    in_error = True
    
                        elif error_type == 'abs error' and mode == 'fwd-fd':
                            # Either analytic or approximated derivatives contain a NaN.
                            in_error = True
    
                        if in_error:
                            wrt_string = '{0} wrt {1}'.format(var, wrt)
                            norm_string = '{}'.format(error_val)
                            bad_derivs.append((wrt_string, norm_string, error_type, mode))
                            len_wrt_width = max(len_wrt_width, len(wrt_string))
                            len_norm_width = max(len_norm_width, len(norm_string))
    
            if bad_derivs:
                comp_error_string = ''
                for wrt_string, norm_string, error_type, mode in bad_derivs:
                    err_msg = '{0} | {1} | {2} | {3}'.format(
                        pad_name(wrt_string, len_wrt_width),
                        pad_name(error_type.split()[0], len_absrel_width),
                        pad_name(mode, len_norm_type_width),
                        pad_name(norm_string, len_norm_width)) + '\n'
                    comp_error_string += err_msg
    
                name_header = 'Component: {}\n'.format(comp)
                len_name_header = len(name_header)
                header = len_name_header * '-' + '\n'
                header += name_header
                header += len_name_header * '-' + '\n'
                header += '{0} | {1} | {2} | {3}'.format(
                    pad_name(wrt_header, len_wrt_width),
                    pad_name(absrel_header, len_absrel_width),
                    pad_name('norm', len_norm_type_width),
                    pad_name(norm_value_header, len_norm_width),
                ) + '\n'
                header += '{0} | {1} | {2} | {3}'.format(
                    len_wrt_width * '-',
                    len_absrel_width * '-',
                    len_norm_type_width * '-',
                    len_norm_width * '-',
                ) + '\n'
                comp_error_string = header + comp_error_string
                error_string += comp_error_string
    
        # if error string then raise error with that string
        if error_string:
            header_line1 = 'Assert Check Partials failed for the following Components'
            header_line2 = 'with absolute tolerance = {} and relative tolerance = {}'.format(atol, rtol)
            header_width = max(len(header_line1), len(header_line2))
            header = '\n' + header_width * '=' + '\n'
            header += header_line1 + '\n'
            header += header_line2 + '\n'
            header += header_width * '=' + '\n'
            error_string = header + error_string
>           raise ValueError(error_string)
E           ValueError: 
E           ==============================================================
E           Assert Check Partials failed for the following Components
E           with absolute tolerance = 1e-06 and relative tolerance = 1e-06
E           ==============================================================
E           -------------------------
E           Component: rk_integrator
E           -------------------------
E           < output > wrt < variable > | abs/rel | norm   | norm value           
E           --------------------------- | ------- | ------ | ---------------------
E           x_final wrt b               | rel     | fwd-fd | 2.386963172449967e-05
E           x_final wrt b               | rel     | rev-fd | 2.386963172484361e-05

/home/shuv_im/.spack/rev.23.05/install/linux-rocky8-zen2/gcc-10.4.0/py-openmdao-3.9.1-dlr.6-w57zdo/lib/python3.9/site-packages/openmdao/utils/assert_utils.py:225: ValueError
----------------------------- Captured stdout call -----------------------------


Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.
Starting stage 5 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.
Starting stage 5 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.
Starting stage 5 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.
Starting stage 5 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.
Starting stage 5 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.
Starting stage 5 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.
Starting stage 5 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.
Starting stage 5 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting fwd-mode jacvec product


Resetting error estimator.


Starting step 1 of fwd-mode jacvec product.
Time = 1.0, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 1.
Starting stage 2 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 1.
Starting stage 3 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 1.
Starting stage 4 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 1.
Starting stage 5 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 5 of fwd-mode jacvec product in step 1.

Finished step 1 of fwd-mode jacvec product.


Starting step 2 of fwd-mode jacvec product.
Time = 1.001, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 2.
Starting stage 2 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 2.
Starting stage 3 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 2.
Starting stage 4 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 2.
Starting stage 5 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 5 of fwd-mode jacvec product in step 2.

Finished step 2 of fwd-mode jacvec product.


Starting step 3 of fwd-mode jacvec product.
Time = 1.0022680375324058, dTime = 0.0012680375324058762.

Starting stage 1 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 3.
Starting stage 2 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 3.
Starting stage 3 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 3.
Starting stage 4 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 3.
Starting stage 5 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 5 of fwd-mode jacvec product in step 3.

Finished step 3 of fwd-mode jacvec product.


Starting step 4 of fwd-mode jacvec product.
Time = 1.0050827632100559, dTime = 0.002814725677650158.

Starting stage 1 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 4.
Starting stage 2 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 4.
Starting stage 3 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 4.
Starting stage 4 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 4.
Starting stage 5 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 5 of fwd-mode jacvec product in step 4.

Finished step 4 of fwd-mode jacvec product.



Finished fwd-mode jacvec product




Starting fwd-mode jacvec product


Resetting error estimator.


Starting step 1 of fwd-mode jacvec product.
Time = 1.0, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 1.
Starting stage 2 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 1.
Starting stage 3 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 1.
Starting stage 4 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 1.
Starting stage 5 of fwd-mode jacvec product in step 1.
NL: Newton Converged in 0 iterations
Finished stage 5 of fwd-mode jacvec product in step 1.

Finished step 1 of fwd-mode jacvec product.


Starting step 2 of fwd-mode jacvec product.
Time = 1.001, dTime = 0.001.

Starting stage 1 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 2.
Starting stage 2 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 2.
Starting stage 3 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 2.
Starting stage 4 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 2.
Starting stage 5 of fwd-mode jacvec product in step 2.
NL: Newton Converged in 0 iterations
Finished stage 5 of fwd-mode jacvec product in step 2.

Finished step 2 of fwd-mode jacvec product.


Starting step 3 of fwd-mode jacvec product.
Time = 1.0022680375324058, dTime = 0.0012680375324058762.

Starting stage 1 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 3.
Starting stage 2 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 3.
Starting stage 3 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 3.
Starting stage 4 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 3.
Starting stage 5 of fwd-mode jacvec product in step 3.
NL: Newton Converged in 0 iterations
Finished stage 5 of fwd-mode jacvec product in step 3.

Finished step 3 of fwd-mode jacvec product.


Starting step 4 of fwd-mode jacvec product.
Time = 1.0050827632100559, dTime = 0.002814725677650158.

Starting stage 1 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of fwd-mode jacvec product in step 4.
Starting stage 2 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of fwd-mode jacvec product in step 4.
Starting stage 3 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of fwd-mode jacvec product in step 4.
Starting stage 4 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of fwd-mode jacvec product in step 4.
Starting stage 5 of fwd-mode jacvec product in step 4.
NL: Newton Converged in 0 iterations
Finished stage 5 of fwd-mode jacvec product in step 4.

Finished step 4 of fwd-mode jacvec product.



Finished fwd-mode jacvec product




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.
Starting stage 5 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.
Starting stage 5 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.
Starting stage 5 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.
Starting stage 5 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting rev-mode jacvec product



Starting step 4 of rev-mode jacvec product.
Time = 1.0050827632100559, dTime = 0.004917236789944157.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 3 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Finished stage 3 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 4 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.
Finished stage 4 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 5 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 5 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 4.
Finished stage 5 of the fwd iteration of rev-mode jvp in
step 4.
Starting stage 5 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 5 of the rev iteration of reve-mode jvp in
step 4.
Starting stage 4 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 4 of the rev iteration of reve-mode jvp in
step 4.
Starting stage 3 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 3 of the rev iteration of reve-mode jvp in
step 4.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 4.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 4.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 4.

Finishing step 4 of rev-mode jacvec product.


Starting step 3 of rev-mode jacvec product.
Time = 1.0022680375324058, dTime = 0.002814725677650158.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 3 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Finished stage 3 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 4 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.
Finished stage 4 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 5 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 5 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 3.
Finished stage 5 of the fwd iteration of rev-mode jvp in
step 3.
Starting stage 5 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 5 of the rev iteration of reve-mode jvp in
step 3.
Starting stage 4 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 4 of the rev iteration of reve-mode jvp in
step 3.
Starting stage 3 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 3 of the rev iteration of reve-mode jvp in
step 3.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 3.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 3.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 3.

Finishing step 3 of rev-mode jacvec product.


Starting step 2 of rev-mode jacvec product.
Time = 1.001, dTime = 0.0012680375324058762.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 3 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Finished stage 3 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 4 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.
Finished stage 4 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 5 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 5 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 2.
Finished stage 5 of the fwd iteration of rev-mode jvp in
step 2.
Starting stage 5 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 5 of the rev iteration of reve-mode jvp in
step 2.
Starting stage 4 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 4 of the rev iteration of reve-mode jvp in
step 2.
Starting stage 3 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 3 of the rev iteration of reve-mode jvp in
step 2.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 2.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 2.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 2.

Finishing step 2 of rev-mode jacvec product.


Starting step 1 of rev-mode jacvec product.
Time = 1.0, dTime = 0.001.

Starting stage 1 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Finished stage 1 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 2 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Finished stage 2 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 3 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Finished stage 3 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 4 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.
Finished stage 4 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 5 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 5 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 1.
Finished stage 5 of the fwd iteration of rev-mode jvp in
step 1.
Starting stage 5 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 5 of the rev iteration of reve-mode jvp in
step 1.
Starting stage 4 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 4 of the rev iteration of reve-mode jvp in
step 1.
Starting stage 3 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 3 of the rev iteration of reve-mode jvp in
step 1.
Starting stage 2 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 2 of the rev iteration of reve-mode jvp in
step 1.
Starting stage 1 of the rev iteration of rev-mode jvp in
step 1.
Finished stage 1 of the rev iteration of reve-mode jvp in
step 1.

Finishing step 1 of rev-mode jacvec product.



Finished rev-mode jacvec product




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.
Starting stage 5 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.
Starting stage 5 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.
Starting stage 5 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.
Starting stage 5 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.
Starting stage 5 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.
Starting stage 5 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.
Starting stage 5 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.
Starting stage 5 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 4.

Finishing step 4 of compute.



Finishing compute




Starting compute


Resetting error estimator.


Starting step 1 of compute.

Starting stage 1 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 1.
Starting stage 2 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 1.
Starting stage 3 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 1.
Starting stage 4 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 1.
Starting stage 5 of compute in step 1.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 1.

Finishing step 1 of compute.


Starting step 2 of compute.

Starting stage 1 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 2.
Starting stage 2 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 2.
Starting stage 3 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 2.
Starting stage 4 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 2.
Starting stage 5 of compute in step 2.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 2.

Finishing step 2 of compute.


Starting step 3 of compute.

Starting stage 1 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 3.
Starting stage 2 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 3.
Starting stage 3 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 3.
Starting stage 4 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 3.
Starting stage 5 of compute in step 3.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 3.

Finishing step 3 of compute.


Starting step 4 of compute.

Starting stage 1 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 1 of compute in step 4.
Starting stage 2 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 2 of compute in step 4.
Starting stage 3 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 3 of compute in step 4.
Starting stage 4 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 4 of compute in step 4.
Starting stage 5 of compute in step 4.
NL: Newton Converged in 0 iterations
Finished stage 5 of compute in step 4.

Finishing step 4 of compute.



Finishing compute


-----------------------------------------------
Component: RungeKuttaIntegrator 'rk_integrator'
-----------------------------------------------
  rk_integrator: 'x_final' wrt 'b'
     Forward Magnitude: 1.008762e-02
     Reverse Magnitude: 1.008762e-02
          Fd Magnitude: 1.008738e-02 (fd:forward)
    Absolute Error (Jfor - Jfd) : 2.407821e-07
    Absolute Error (Jrev - Jfd) : 2.407821e-07
    Absolute Error (Jfor - Jrev): 3.469447e-18

    Relative Error (Jfor - Jfd) / Jfd : 2.386963e-05 *
    Relative Error (Jrev - Jfd) / Jfd : 2.386963e-05 *
    Relative Error (Jfor - Jrev) / Jfd: 3.439393e-16

    Raw Forward Derivative (Jfor)
[[0.01008762]]

    Raw Reverse Derivative (Jrev)
[[0.01008762]]

    Raw FD Derivative (Jfd)
[[0.01008738]]

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  rk_integrator: 'x_final' wrt 'x_initial'
     Forward Magnitude: 1.010050e+00
     Reverse Magnitude: 1.010050e+00
          Fd Magnitude: 1.010050e+00 (fd:forward)
    Absolute Error (Jfor - Jfd) : 2.349698e-11
    Absolute Error (Jrev - Jfd) : 2.349676e-11
    Absolute Error (Jfor - Jrev): 2.220446e-16

    Relative Error (Jfor - Jfd) / Jfd : 2.326318e-11
    Relative Error (Jrev - Jfd) / Jfd : 2.326296e-11
    Relative Error (Jfor - Jrev) / Jfd: 2.198352e-16

    Raw Forward Derivative (Jfor)
[[1.01005017]]

    Raw Reverse Derivative (Jrev)
[[1.01005017]]

    Raw FD Derivative (Jfd)
[[1.01005017]]

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
=============================== warnings summary ===============================
../../../../../../../../../home/shuv_im/.spack/rev.23.05/install/linux-rocky8-zen2/gcc-10.4.0/py-openmdao-3.9.1-dlr.6-w57zdo/lib/python3.9/site-packages/openmdao/components/exec_comp.py:7
../../../../../../../../../home/shuv_im/.spack/rev.23.05/install/linux-rocky8-zen2/gcc-10.4.0/py-openmdao-3.9.1-dlr.6-w57zdo/lib/python3.9/site-packages/openmdao/components/exec_comp.py:7
  /home/shuv_im/.spack/rev.23.05/install/linux-rocky8-zen2/gcc-10.4.0/py-openmdao-3.9.1-dlr.6-w57zdo/lib/python3.9/site-packages/openmdao/components/exec_comp.py:7: DeprecationWarning: `np.complex` is a deprecated alias for the builtin `complex`. To silence this warning, use `complex` by itself. Doing this will not modify any behavior and is safe. If you specifically wanted the numpy scalar type, use `np.complex128` here.
  Deprecated in NumPy 1.20; for more details and guidance: https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations
    from numpy import ndarray, imag, complex as npcomplex

../../../../../../../../../home/shuv_im/.spack/rev.23.05/install/linux-rocky8-zen2/gcc-10.4.0/py-openmdao-3.9.1-dlr.6-w57zdo/lib/python3.9/site-packages/openmdao/components/external_code_comp.py:6
  /home/shuv_im/.spack/rev.23.05/install/linux-rocky8-zen2/gcc-10.4.0/py-openmdao-3.9.1-dlr.6-w57zdo/lib/python3.9/site-packages/openmdao/components/external_code_comp.py:6: DeprecationWarning: 
  
    `numpy.distutils` is deprecated since NumPy 1.23.0, as a result
    of the deprecation of `distutils` itself. It will be removed for
    Python >= 3.12. For older Python versions it will remain present.
    It is recommended to use `setuptools < 60.0` for those Python versions.
    For more details, see:
      https://numpy.org/devdocs/reference/distutils_status_migration.html 
  
  
    import numpy.distutils

../../../../../../../../../home/shuv_im/.spack/rev.23.05/install/linux-rocky8-zen2/gcc-10.4.0/py-openmdao-3.9.1-dlr.6-w57zdo/lib/python3.9/site-packages/openmdao/surrogate_models/response_surface.py:7
  /home/shuv_im/.spack/rev.23.05/install/linux-rocky8-zen2/gcc-10.4.0/py-openmdao-3.9.1-dlr.6-w57zdo/lib/python3.9/site-packages/openmdao/surrogate_models/response_surface.py:7: DeprecationWarning: The module numpy.dual is deprecated.  Instead of using dual, use the functions directly from numpy or scipy.
    from numpy.dual import lstsq

test_component_test_adaptive.py:59
  /scratch/ws/m0/shuv_im-shuv_im/shuv_im-imris_workspace-1724036464/MDAO/rkopenmdao/rkopenmdao/tests/test_component_test_adaptive.py:59: PytestUnknownMarkWarning: Unknown pytest.mark.rk - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.rk

test_component_test_adaptive.py:60
  /scratch/ws/m0/shuv_im-shuv_im/shuv_im-imris_workspace-1724036464/MDAO/rkopenmdao/rkopenmdao/tests/test_component_test_adaptive.py:60: PytestUnknownMarkWarning: Unknown pytest.mark.rk_openmdao - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.rk_openmdao

test_component_test_adaptive.py:82
  /scratch/ws/m0/shuv_im-shuv_im/shuv_im-imris_workspace-1724036464/MDAO/rkopenmdao/rkopenmdao/tests/test_component_test_adaptive.py:82: PytestUnknownMarkWarning: Unknown pytest.mark.rk - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.rk

test_component_test_adaptive.py:83
  /scratch/ws/m0/shuv_im-shuv_im/shuv_im-imris_workspace-1724036464/MDAO/rkopenmdao/rkopenmdao/tests/test_component_test_adaptive.py:83: PytestUnknownMarkWarning: Unknown pytest.mark.rk_openmdao - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.rk_openmdao

test_component_test_adaptive.py:164
  /scratch/ws/m0/shuv_im-shuv_im/shuv_im-imris_workspace-1724036464/MDAO/rkopenmdao/rkopenmdao/tests/test_component_test_adaptive.py:164: PytestUnknownMarkWarning: Unknown pytest.mark.rk - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.rk

test_component_test_adaptive.py:165
  /scratch/ws/m0/shuv_im-shuv_im/shuv_im-imris_workspace-1724036464/MDAO/rkopenmdao/rkopenmdao/tests/test_component_test_adaptive.py:165: PytestUnknownMarkWarning: Unknown pytest.mark.rk_openmdao - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.rk_openmdao

test_component_test_adaptive.py:244
  /scratch/ws/m0/shuv_im-shuv_im/shuv_im-imris_workspace-1724036464/MDAO/rkopenmdao/rkopenmdao/tests/test_component_test_adaptive.py:244: PytestUnknownMarkWarning: Unknown pytest.mark.rk - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.rk

test_component_test_adaptive.py:245
  /scratch/ws/m0/shuv_im-shuv_im/shuv_im-imris_workspace-1724036464/MDAO/rkopenmdao/rkopenmdao/tests/test_component_test_adaptive.py:245: PytestUnknownMarkWarning: Unknown pytest.mark.rk_openmdao - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.rk_openmdao

test_component_test_adaptive.py:336
  /scratch/ws/m0/shuv_im-shuv_im/shuv_im-imris_workspace-1724036464/MDAO/rkopenmdao/rkopenmdao/tests/test_component_test_adaptive.py:336: PytestUnknownMarkWarning: Unknown pytest.mark.rk - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.rk

test_component_test_adaptive.py:337
  /scratch/ws/m0/shuv_im-shuv_im/shuv_im-imris_workspace-1724036464/MDAO/rkopenmdao/rkopenmdao/tests/test_component_test_adaptive.py:337: PytestUnknownMarkWarning: Unknown pytest.mark.rk_openmdao - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.rk_openmdao

test_component_test_adaptive.py:434
  /scratch/ws/m0/shuv_im-shuv_im/shuv_im-imris_workspace-1724036464/MDAO/rkopenmdao/rkopenmdao/tests/test_component_test_adaptive.py:434: PytestUnknownMarkWarning: Unknown pytest.mark.rk - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.rk

test_component_test_adaptive.py:435
  /scratch/ws/m0/shuv_im-shuv_im/shuv_im-imris_workspace-1724036464/MDAO/rkopenmdao/rkopenmdao/tests/test_component_test_adaptive.py:435: PytestUnknownMarkWarning: Unknown pytest.mark.rk_openmdao - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.rk_openmdao

tests/test_component_test_adaptive.py: 240 warnings
  /home/shuv_im/.spack/rev.23.05/install/linux-rocky8-zen2/gcc-10.4.0/py-openmdao-3.9.1-dlr.6-w57zdo/lib/python3.9/site-packages/openmdao/core/group.py:1624: DeprecationWarning: OrderedGraph is deprecated and will be removed in version 3.0.
  Use `Graph` instead, which guarantees order is preserved for
  Python >= 3.7
  
    self._shapes_graph = graph = nx.OrderedGraph()  # ordered graph for consistency across procs

tests/test_component_test_adaptive.py: 240 warnings
  /home/shuv_im/.spack/rev.23.05/install/linux-rocky8-zen2/gcc-10.4.0/py-openmdao-3.9.1-dlr.6-w57zdo/lib/python3.9/site-packages/openmdao/core/group.py:1691: DeprecationWarning: OrderedGraph is deprecated and will be removed in version 3.0.
  Use `Graph` instead, which guarantees order is preserved for
  Python >= 3.7
  
    graph = nx.OrderedGraph()  # ordered graph for consistency across procs

tests/test_component_test_adaptive.py: 2530 warnings
  <decorator-gen-5>:2: DeprecationWarning: scipy.sparse.linalg.gmres called without specifying `callback_type`. The default value will be changed in a future release. For compatibility, specify a value for `callback_type` explicitly, e.g., ``{name}(..., callback_type='pr_norm')``, or to retain the old behavior ``{name}(..., callback_type='legacy')``

tests/test_component_test_adaptive.py: 60 warnings
  /home/shuv_im/.spack/rev.23.05/install/linux-rocky8-zen2/gcc-10.4.0/py-openmdao-3.9.1-dlr.6-w57zdo/lib/python3.9/site-packages/openmdao/jacobians/jacobian.py:315: DeprecationWarning: Calling np.sum(generator) is deprecated, and in the future will give a different result. Use np.sum(np.fromiter(generator)) or the python sum builtin instead.
    ncols = np.sum(end - start for _, start, end, _, _ in col_var_info.values())

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED test_component_test_adaptive.py::test_time_integration_with_parameter_partials[PID-SimpleErrorEstimator-AllCheckpointer-butcher_tableau0-1.0-TestComp1-0.0]
FAILED test_component_test_adaptive.py::test_time_integration_with_parameter_partials[PID-SimpleErrorEstimator-AllCheckpointer-butcher_tableau0-1.0-TestComp1-1.0]
FAILED test_component_test_adaptive.py::test_time_integration_with_parameter_partials[PID-SimpleErrorEstimator-AllCheckpointer-butcher_tableau1-1.0-TestComp1-0.0]
FAILED test_component_test_adaptive.py::test_time_integration_with_parameter_partials[PID-SimpleErrorEstimator-AllCheckpointer-butcher_tableau1-1.0-TestComp1-1.0]
FAILED test_component_test_adaptive.py::test_time_integration_with_parameter_partials[PID-SimpleErrorEstimator-AllCheckpointer-butcher_tableau3-1.0-TestComp1-0.0]
FAILED test_component_test_adaptive.py::test_time_integration_with_parameter_partials[PID-SimpleErrorEstimator-AllCheckpointer-butcher_tableau3-1.0-TestComp1-1.0]
FAILED test_component_test_adaptive.py::test_time_integration_with_parameter_partials[PID-SimpleErrorEstimator-AllCheckpointer-butcher_tableau4-1.0-TestComp1-0.0]
FAILED test_component_test_adaptive.py::test_time_integration_with_parameter_partials[PID-SimpleErrorEstimator-AllCheckpointer-butcher_tableau4-1.0-TestComp1-1.0]
FAILED test_component_test_adaptive.py::test_time_integration_with_parameter_partials[PID-ImprovedErrorEstimator-AllCheckpointer-butcher_tableau0-1.0-TestComp1-0.0]
FAILED test_component_test_adaptive.py::test_time_integration_with_parameter_partials[PID-ImprovedErrorEstimator-AllCheckpointer-butcher_tableau0-1.0-TestComp1-1.0]
FAILED test_component_test_adaptive.py::test_time_integration_with_parameter_partials[PID-ImprovedErrorEstimator-AllCheckpointer-butcher_tableau1-1.0-TestComp1-0.0]
FAILED test_component_test_adaptive.py::test_time_integration_with_parameter_partials[PID-ImprovedErrorEstimator-AllCheckpointer-butcher_tableau1-1.0-TestComp1-1.0]
FAILED test_component_test_adaptive.py::test_time_integration_with_parameter_partials[PID-ImprovedErrorEstimator-AllCheckpointer-butcher_tableau3-1.0-TestComp1-0.0]
FAILED test_component_test_adaptive.py::test_time_integration_with_parameter_partials[PID-ImprovedErrorEstimator-AllCheckpointer-butcher_tableau3-1.0-TestComp1-1.0]
FAILED test_component_test_adaptive.py::test_time_integration_with_parameter_partials[PID-ImprovedErrorEstimator-AllCheckpointer-butcher_tableau4-1.0-TestComp1-0.0]
FAILED test_component_test_adaptive.py::test_time_integration_with_parameter_partials[PID-ImprovedErrorEstimator-AllCheckpointer-butcher_tableau4-1.0-TestComp1-1.0]
================ 16 failed, 104 passed, 3086 warnings in 25.73s ================
